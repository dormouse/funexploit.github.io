
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>嵌入式系统笔记 &mdash; funexploit 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="funexploit 1.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">funexploit 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id30">嵌入式系统笔记</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id30">嵌入式系统笔记</a><ul>
<li><a class="reference internal" href="#id2" id="id31">概述</a></li>
<li><a class="reference internal" href="#id3" id="id32">嵌入式开发环境设置</a><ul>
<li><a class="reference internal" href="#id4" id="id33">交叉编译环境设置</a></li>
<li><a class="reference internal" href="#id5" id="id34">调试工具设置</a></li>
<li><a class="reference internal" href="#id6" id="id35">关于调试工具的疑难问题</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7" id="id36">编写裸机代码时需要做的准备工作</a><ul>
<li><a class="reference internal" href="#arm" id="id37">ARM汇编</a></li>
<li><a class="reference internal" href="#id8" id="id38">其它</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9" id="id39">学习计划</a></li>
<li><a class="reference internal" href="#id10" id="id40">参考资料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11" id="id41">各子系统裸机开发笔记</a><ul>
<li><a class="reference internal" href="#id12" id="id42">系统初始化</a></li>
<li><a class="reference internal" href="#led" id="id43">LED</a></li>
<li><a class="reference internal" href="#id13" id="id44">时钟</a></li>
<li><a class="reference internal" href="#uart" id="id45">串口UART</a></li>
<li><a class="reference internal" href="#sdram" id="id46">内存SDRAM</a><ul>
<li><a class="reference internal" href="#id14" id="id47">概述</a></li>
<li><a class="reference internal" href="#id15" id="id48">背景知识</a><ul>
<li><a class="reference internal" href="#id16" id="id49">时间参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17" id="id50">初始化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nandflash" id="id51">硬盘NandFlash</a><ul>
<li><a class="reference internal" href="#id18" id="id52">概述</a></li>
<li><a class="reference internal" href="#id19" id="id53">背景知识</a></li>
<li><a class="reference internal" href="#id20" id="id54">初始化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21" id="id55">中断和异常</a></li>
<li><a class="reference internal" href="#mmu" id="id56">MMU</a></li>
</ul>
</li>
<li><a class="reference internal" href="#u-boot" id="id57">u-boot移植</a></li>
<li><a class="reference internal" href="#id22" id="id58">驱动程序开发</a><ul>
<li><a class="reference internal" href="#id23" id="id59">概述</a><ul>
<li><a class="reference internal" href="#id24" id="id60">主要文件介绍</a></li>
<li><a class="reference internal" href="#id25" id="id61">其他</a></li>
<li><a class="reference internal" href="#id26" id="id62">辅助工具</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id27" id="id63">串口</a><ul>
<li><a class="reference internal" href="#id28" id="id64">主要的数据结构</a></li>
<li><a class="reference internal" href="#id29" id="id65">主要的操作</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nand-flash" id="id66">Nand Flash</a></li>
<li><a class="reference internal" href="#usb" id="id67">USB</a></li>
<li><a class="reference internal" href="#network" id="id68">Network</a></li>
<li><a class="reference internal" href="#platform" id="id69">Platform</a></li>
</ul>
</li>
</ul>
</div>
<p>为了学习linux驱动和内核的开发，买了块友善tiny6410的板子，开始了嵌入式系统的学习。本文是我在学习过程中的笔记，会随着自己的学习持续更新，文章如有错误，敬请指正。</p>
<p>另外寻求有兴趣的朋友一起学习折腾、实时交流心得体会和问题。 <a class="reference external" href="funexploit#gmail.com">funexploit # gmail.com</a></p>
<p>使用的主机配置如下</p>
<div class="highlight-python"><pre>root@mygentoo 7.Embeddedsystem # uname -a
Linux mygentoo 3.9.3-gentoo #4 SMP Thu May 30 07:32:10 CST 2013 i686 Intel(R) Core(TM)2 Duo CPU T6500 @ 2.10GHz GenuineIntel GNU/Linux</pre>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id31">概述</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>tiny6410开发板包括核心板和底板，核心板上包括了三星的S3C6410微处理器和2块Mobile DDR RAM(即内存)，以及一块Nand Flash(相当于PC机上的硬盘)。其中的S3C6410微处理器内部内部包含了ARM公司的CPU(即arm1176)和其它一些控制器，具体可查看三星的手册，CPU和这些控制器组合起来又称SOC(线上系统)，作用相当于PC机上的CPU和主板的组合。</p>
<p>在S3C6410内部包含了一个4K的SRAM，系统上电启动后会自动将Nand Flash前4K的内容复制到这个内部的SRAM中，接着CPU就会从这个4K的SRAM的起始地址开始执行，地址为0x0000_0000(这整个过程是和CPU相关的，是硬件实现的)，而外部的内存(即那2个Mobile DDR RAM)的起始地址为0x3000_0000，假如我们有2个128M的内存，那么结束地址定义为0x3000_0000+2*(128*1024*1024)=0x4000_0000。</p>
<p>这4K的SRAM的代码的主要功能包括：初始化系统，初始化外部硬件(包括RAM和Nand Flash等)，将Nand Flash上更多的内容复制到内存中，然后跳转过去开始执行。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id32">嵌入式开发环境设置</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id33">交叉编译环境设置</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>参考： Gentoo Embedded Handbook</p>
<p>安装corssdev</p>
<blockquote>
<div><div class="highlight-python"><pre>emerge crossdev</pre>
</div>
</div></blockquote>
<p>安装交叉编译环境，包括gdb</p>
<blockquote>
<div><div class="highlight-python"><pre>crossdev --ex-gdb --target arm-unknown-linux-gnueabi</pre>
</div>
</div></blockquote>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id34">调试工具设置</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">串口：linux下USB转串口的驱动支持</p>
<p>将串口转USB接口插到主机上，然后执行 lsusb 命令，会出现如下输出</p>
<div class="highlight-python"><pre>Bus 004 Device 002: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port</pre>
</div>
<p>说明已经被识别，但是随后却找不到 /dev/ttyUSB0 这个设备文件，说明可能是驱动程序没有安装，需要重新编译内核。开启内核中的相关选项，如下所示</p>
<div class="highlight-python"><pre>Symbol: USB_SERIAL_PL2303 [=m]
Type  : tristate
Prompt: USB Prolific 2303 Single Port Serial Driver
  Defined at drivers/usb/serial/Kconfig:480
  Depends on: USB_SUPPORT [=y] &amp;&amp; USB_SERIAL [=y]
  Location:
    -&gt; Device Drivers
      -&gt; USB support (USB_SUPPORT [=y])
        -&gt; USB Serial Converter support (USB_SERIAL [=y])</pre>
</div>
</li>
<li><p class="first">JTAG调试程序：openocd</p>
<p>安装</p>
<div class="highlight-python"><pre>emerge openocd</pre>
</div>
<p>安装之前要在/etc/portage/package.use/package.use中设置openocd的USE标
志：segger</p>
<div class="highlight-python"><pre>dev-embedded/openocd segger</pre>
</div>
<p>配置文件</p>
<p>将/usr/share/openocd/scripts/board/mini6410.cfg复制为/root/openocd.cfg，根据自己的需要修改里面的参数。</p>
</li>
<li><p class="first">超级终端：minicom</p>
<p>安装</p>
<div class="highlight-python"><pre>emerge minicom</pre>
</div>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id35">关于调试工具的疑难问题</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">openocd出现以下错误</p>
<div class="highlight-python"><pre>'arm11 target' JTAG error SCREG OUT 0x00
in procedure 'resume'
'arm11 target' JTAG error SCREG OUT 0x00
Polling target s3c6410.cpu failed, GDB will be halted. Polling again in 100ms</pre>
</div>
<p>这种错误出现在配置了时钟之后执行resume时，由于配置文件里的adapter_khz参数设置问题，默认为1000，修改为与CPU时钟相同(533000khz)，调试时会出现如下提示</p>
<div class="highlight-python"><pre>Polling target s3c6410.cpu succeeded again</pre>
</div>
<p>可以正常进行调试，就当权宜之计吧。</p>
<p>有时上面的步骤不起作用时，可以尝试将u-boot写到nand flash里然后重启，就正常了，不明白什么原因。</p>
</li>
</ol>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id36">编写裸机代码时需要做的准备工作</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="section" id="arm">
<h3><a class="toc-backref" href="#id37">ARM汇编</a><a class="headerlink" href="#arm" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id38">其它</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id39">学习计划</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>第一阶段:裸机调试 编写汇编或者c代码来直接操纵硬件和接口<ul>
<li>预备：ARM汇编语言</li>
<li>LED、按键、蜂鸣器</li>
<li>时钟</li>
<li>串口(UART)</li>
<li>内存控制器(DDR SDRAM)</li>
<li>Nand Flash</li>
<li>中断和异常</li>
<li>MMU</li>
<li>bootloader开发</li>
<li>I2C总线接口</li>
<li>LCD控制器</li>
</ul>
</li>
<li>第二阶段:系统移植<ul>
<li>bootloader移植</li>
<li>移植linux内核</li>
<li>构建linux系统</li>
</ul>
</li>
<li>第三阶段:驱动开发<ul>
<li>一个基于内存的字符设备驱动</li>
<li>一个基于内存的块设备驱动</li>
<li>一个基于内存的网卡驱动</li>
<li>按键控制的LED驱动、看门狗、蜂鸣器</li>
<li>触摸屏、LCD</li>
<li>I2C-EEPROM</li>
<li>Nand Flash驱动</li>
<li>USB</li>
<li>以太网卡、WiFi驱动</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id40">参考资料</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">嵌入式硬件设计(卡特索利斯)</p>
<p>一本全面介绍基本硬件知识的书，没有复杂的原理，没有繁琐的公式，讲述非常浅显易懂，对于初涉嵌入式领域的软件开发人员绝对是一本普及硬件知识的好书。</p>
</li>
<li><p class="first">ARM体系结构与编程(杜春雷)</p>
<p>描述ARM处理器的内部原理以及ARM汇编语言的一本书，还包括了ARM的存储管理、异常和中断等等，书中的有些部分需要仔细研读，而有些部分可以在需要时参考。</p>
</li>
<li><p class="first">嵌入式Linux应用开发完全手册(韦东山)</p>
<p>这是一本以实践操作驱动的书，最出彩的部分莫过于其中的第二部分，也就是裸机开发，跳过操作系统这个中间层，直接去操纵硬件，把这部分踏踏实实掌握了，到了linux下做驱动开发的时候才能游刃有余。这本书还配有详细的视频教程，非常赞，一起学习会事半功倍。</p>
</li>
<li><p class="first">Linux设备驱动开发详解（宋宝华）</p>
<p>也是一本实践驱动的书，详细讲解了各种类型的设备驱动程序的详细开发过程，可以和LDD搭配起来一起看，以这本书为实践主线，以LDD为参考。</p>
</li>
<li><p class="first">Linux设备驱动程序(俗称LDD)</p>
<p>学习linux驱动和内核的一本必备经典图书，从内核的角度对驱动程序的开发进行了详尽的描述，偏重原理性的讲解。</p>
</li>
<li><p class="first">嵌入式linux设备驱动开发详解</p>
</li>
<li><p class="first">嵌入式系统linux内核开发实战指南</p>
</li>
</ul>
</div>
</div>
<div class="section" id="id11">
<h1><a class="toc-backref" href="#id41">各子系统裸机开发笔记</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id42">系统初始化</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>包括两个步骤，第一步是告诉CPU外设的地址，这样在访问外设时就可以像访问内存那样方便。第二步是禁用电子狗。</p>
<ul>
<li><p class="first">外设地址映射</p>
<p>首先，我们需要告诉CPU外设的地址，这样在访问外设时就可以像访问内存那样方便。</p>
<blockquote>
<div><img alt="../_images/datasheet_init_peripheral.png" src="../_images/datasheet_init_peripheral.png" />
</div></blockquote>
<p>从6410的datasheet上可以看出，外设的地址是0x7000_0000~0x7FFF_0000，大小为256M(即2^28)。所需指令为</p>
<div class="highlight-python"><pre>ldr r0, =0x70000000
orr r0, r0, #0x13
mcr p15, 0, r0, c15, c2, 4</pre>
</div>
<p>这里用到了arm的协处理器CP15，协处理器包含了16个32位的寄存器，这里使用到的是c15，它的格式如下(取自arm1176手册arm1176jzfs.pdf)</p>
<blockquote>
<div><img alt="../_images/arm1176jzfs_c15_format.png" src="../_images/arm1176jzfs_c15_format.png" />
</div></blockquote>
<p>下面是对c15寄存器进行操作的指令格式</p>
<blockquote>
<div><img alt="../_images/arm1176jzfs_c15_readwrite.png" src="../_images/arm1176jzfs_c15_readwrite.png" />
</div></blockquote>
<p>由于我们的外设地址大小是256M，从图中可以看出c15的最低5位需要设置为b10011，即0x13。</p>
<div class="highlight-python"><pre>orr r0, r0, #0x13</pre>
</div>
</li>
<li><p class="first">关闭电子狗</p>
<img alt="../_images/datasheet_watchdog_WTCON.png" src="../_images/datasheet_watchdog_WTCON.png" />
<p>将WTCON最低位置0即可。</p>
<div class="highlight-python"><pre>ldr r0, =0x7E004000
mov r1, #0
str r1, [r0]</pre>
</div>
</li>
</ul>
</div>
<div class="section" id="led">
<h2><a class="toc-backref" href="#id43">LED</a><a class="headerlink" href="#led" title="Permalink to this headline">¶</a></h2>
<img alt="../_images/board_led.png" src="../_images/board_led.png" />
<p>上图为tiny6410核心板原理图关于LED的部分，可以看出led1-4由GPK4-7控制，并且这些引脚是复用引脚，点亮led需要对应的引脚为为低电平。</p>
<img alt="../_images/datasheet_led_register.png" src="../_images/datasheet_led_register.png" />
<p>这是tiny6410的datasheet中关于GPK寄存器的截图。我们的目的是让led根据设置的引脚来相应地发生变化，所以它们应该为输出模式，从图可以看出GPK4-7分别由GPKCON0的[19:16]、[23:20]、[27:24]和[31:28]控制，需要将其分别设置为b0001。</p>
<p>GPK4-7的值可以通过向GPKDAT[n]对应的位写入即可。</p>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id44">时钟</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">概述</p>
<img alt="../_images/datasheet_clock_3-2.png" src="../_images/datasheet_clock_3-2.png" />
<p>这是tiny6410的datasheet中图3-2，为时钟的总体布局图。</p>
<p>6410有很多时钟，比如CPU时钟、总线时钟和各种外设时钟，时钟源也有很多，有一个主时钟源和其它次要的时钟源。主时钟源通过转换，生成6410的几个最主要的时钟：CPU时钟、AXI/AHB总线时钟和APB总线时钟，分别对应于上图中的ARMCLK、HCLK和PCLK。</p>
<p>6410有3个PLL来转换生成这三种不同的时钟：即上图中的APLL(ARM PLL)、MPLL(Main PLL)和EPLL(extra PLL)，它们的输入时钟都是上面的主时钟源。我们可以将PLL看成一个黑盒子，它将一个时钟输入转换为另一个时钟输出。</p>
<p>主时钟源可以选择外部晶体(XXTlpll)(通过晶振产生时钟)或者直接选择一个外部时钟(XEXTCLK)，由OM[0]的值来决定，为0时选择外部晶体，为1时选择外部时钟。</p>
</li>
<li><p class="first">寄存器配置原理</p>
<p>我们在配置时钟时，将需求降到最低，即满足系统运行最基本的要求即可，暂时不需要使用EPLL，所以相关的寄存器就不需要配置。基本配置可以对照下图来确定，这是datasheet上图3-4。</p>
<img alt="../_images/datasheet_clock_3-4.png" src="../_images/datasheet_clock_3-4.png" />
<ul>
<li><p class="first">时钟源设置</p>
<p>MUX(APLL)，通过设置CLK_SRC[0]决定CPU时钟直接来自于外部时钟还是来自于APLL的输出。</p>
<p>MUX(MPLL)，通过设置CLK_SRC[1]决定总线时钟来自于外部时钟还是来自于MPLL的输出。</p>
<p>OTHERS[6]决定总线时钟是否来自于CPU时钟。如果OTHERS[6]设置为1，则MPLL的相关设置以及CLK_SRC[1]的值便可以忽略。</p>
<p>另外，OTHERS[7]则决定总线时钟是否和CPU始终保持同步，设置了OTHERS[7]之后可以对OTHERS[11:8]进行检测以便确认已经同步。如果设置为同步模式，稳定了之后这几位为1；如果设置为异步模式，则稳定了之后这几位为0。详见下图关于OTHERS寄存器的描述。(?随后确认)</p>
<img alt="../_images/datasheet_clock_OTHERS.png" src="../_images/datasheet_clock_OTHERS.png" />
</li>
<li><p class="first">分频器设置</p>
<img alt="../_images/datasheet_clock_3-5.png" src="../_images/datasheet_clock_3-5.png" />
<p>可以对照此图来设置。</p>
<p>MISC_CON[19]设置为0，传入DIV(ARM)和DIV(HCLKX2)之前不进行分频。</p>
<p>DIV(ARM)对应于CLK_DIV0[3:0]，设置为0。 <tt class="docutils literal"><span class="pre">Fout(APLL)</span> <span class="pre">=</span> <span class="pre">ARMCLK</span></tt></p>
<p>DIV(HCLKX2)对应于CLK_DIV0[11:9]，设置为1。 <tt class="docutils literal"><span class="pre">ARMCLK</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">HCLKX2</span></tt></p>
<p>DIV(HCLK)对应于CLK_DIV0[8]，设置为1。 <tt class="docutils literal"><span class="pre">HCLKX2</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">HCLK</span></tt></p>
<p>DIV(PCLK)对应于CLK_DIV0[15:12]，设置为3。 <tt class="docutils literal"><span class="pre">HCLKX2</span> <span class="pre">=</span> <span class="pre">4</span> <span class="pre">*</span> <span class="pre">PCLK</span></tt></p>
<img alt="../_images/datasheet_clock_CLK_DIV0.png" src="../_images/datasheet_clock_CLK_DIV0.png" />
<p>这样配置结果为</p>
<div class="highlight-python"><pre>ARMCLK = 2 * HCLKX2 = 4 * HCLK = 8 * PCLK = 533MHz</pre>
</div>
</li>
<li><p class="first">PLL设置</p>
<p>包括倍率设置和lock time设置。</p>
<ul>
<li><p class="first">倍率设置</p>
<p>PLL的倍率转换公式</p>
<div class="highlight-python"><pre>输出时钟频率 = 输入时钟频率 * MDIV / (PDIV * (2 ^ SDIV))</pre>
</div>
<p>公式中除了输入时钟频率之外，其他三个参数都是在PLL寄存器中设置。寄存器APLL_CON和MPLL_CON的最高位为控制是否启用这个PLL，这两个寄存器的[25:16]、[13:8]和[2:0]分别控制相应的PLL的三个值：MDIV、PDIV和SDIV，其余的位为0。详见下图</p>
<img alt="../_images/datasheet_clock_PLL_CON.png" src="../_images/datasheet_clock_PLL_CON.png" />
<p>下图为关于转换公式的具体描述</p>
<img alt="../_images/datasheet_clock_APLL_calc.png" src="../_images/datasheet_clock_APLL_calc.png" />
<p>从tiny6410核心板原理图上可以看出我们使用的是频率为12MHz的晶振。所以当需求输出频率为533时，MDIV、PDIV和SDIV的值分别为266、3和1。</p>
</li>
<li><p class="first">lock time设置</p>
<img alt="../_images/datasheet_clock_PLL_LOCK.png" src="../_images/datasheet_clock_PLL_LOCK.png" />
<p>某个PLL的locktime可以理解为这个PLL从开始工作到输出到预期的稳定时钟需要经历的时间，预设值一般为0xFFFF，在这段时间内，这个PLL的输出时钟为0。寄存器APLL_LOCK/MPLL_LOCK/EPLL_LOCK　的高十六位固定为0，低十六位为各自对应的locktime。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">配置步骤</p>
<ol class="arabic simple">
<li>先配置OTHERS[6]和OTHERS[7]，然后确认进入同步模式</li>
<li>配置各个PLL的PLL_LOCK，保证有稳定的时钟输出</li>
<li>配置分频比例，保证ARMCLK、HCLKX2、HCLK和PCLK符合最终的比例</li>
<li>分别配置每个用到的PLL，通过PLL将初始的时钟频率提升到与最终时钟频率为同一量级</li>
<li>配置每个用到的PLL输出的的MUX选择器，最终输出预期的时钟频率</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="uart">
<h2><a class="toc-backref" href="#id45">串口UART</a><a class="headerlink" href="#uart" title="Permalink to this headline">¶</a></h2>
<img alt="../_images/datasheet_uart_31-1.png" src="../_images/datasheet_uart_31-1.png" />
<p>此图为UART的内部原理图。</p>
<p>UART内部包含有一个数据发送缓冲区和一个数据接收缓冲区，都称为FIFO，还有一个数据发送器(Transmit Shifter)以及一个数据接收器(Receiver Shifter)。如果启用FIFO，发送数据时，先存入FIFO，然后数据发送器从中一个一个取出数据并发送。接收时采用相同的方法。</p>
<p>在发送数据时，发送器会先发送一个起始位，接着发送5个、6个、7个或者8个字节的数据位，然后是一个可选的奇偶校验位以及1个或者2个停止位。接收数据时也是按照类似的方式进行。数据接收器还可以检测到数据的过载错误、奇偶校验错误、帧错误等等。</p>
<p>下面以配置uart0为例，配置的内容包括:</p>
<ul>
<li><p class="first">引脚</p>
<img alt="../_images/board_uart.png" src="../_images/board_uart.png" />
<p>上图为tiny6410核心板原理图，由于uart引脚为复用引脚，需要将其配置为供uart使用的引脚，只需配置GPA0和GPA1。</p>
<img alt="../_images/datasheet_uart_GPACON.png" src="../_images/datasheet_uart_GPACON.png" />
<div class="highlight-python"><div class="highlight"><pre><span class="n">GPACON</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">GPACON</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">UART行控制寄存器ULCONn(UART LINE CONTROL REGISTER)</p>
<img alt="../_images/datasheet_uart_ULCONn.png" src="../_images/datasheet_uart_ULCONn.png" />
<p>我们通过设置ULCON0寄存器将uart0设置为禁用红外模式、禁用奇偶校验、停止位为1位，发送或者接受时每一帧里包括8个数据位。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ULCON0</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">UART控制寄存器UCONn(UART CONTROL REGISTER)</p>
<img alt="../_images/datasheet_uart_UCONn_1.png" src="../_images/datasheet_uart_UCONn_1.png" />
<img alt="../_images/datasheet_uart_UCONn_2.png" src="../_images/datasheet_uart_UCONn_2.png" />
<p>我们将时钟源设置为PCLK，将接受和发送模式都设置为中断/轮询模式、禁用超时检测、禁用回环模式等等</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">UCON0</span>  <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">UART缓冲区寄存器UFCONn(UART FIFO CONTROL REGISTER)</p>
<img alt="../_images/datasheet_uart_UFCONn.png" src="../_images/datasheet_uart_UFCONn.png" />
<p>设置的结果为:启用FIFO，接受缓冲区收到1个字节就触发信号，而发送缓冲区则是在全部发送完成之后即发送缓冲区为空的时候触发信号。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">UFCON0</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">UARTmodem寄存器UMCONn(UART MODEM CONTROL REGISTER)</p>
<img alt="../_images/datasheet_uart_UMCONn.png" src="../_images/datasheet_uart_UMCONn.png" />
<p>禁用自动流量控制、禁用modem interrupt等</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">UMCON0</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">UART时钟和波特率设置(UART CLOCK AND PCLK RELATION)</p>
<p>包括UBRDIVn和UDIVSLOTn这两个寄存器。</p>
<img alt="../_images/datasheet_uart_UBRDIVn.png" src="../_images/datasheet_uart_UBRDIVn.png" />
<img alt="../_images/datasheet_uart_UDIVSLOTn.png" src="../_images/datasheet_uart_UDIVSLOTn.png" />
<p>uart的时钟来自于PCLK，在设置时钟部分我们可以知道PCLK=(533/8)HMz。uart的波特率我们采用通用的115200。uart的时钟和波特率的关系如下:</p>
<div class="highlight-python"><pre>DIV_VAL = UBRDIVn + (num of 1’s in UDIVSLOTn)/16
DIV_VAL = (PCLK / (bps x 16 ) ) −1</pre>
</div>
<p>所以</p>
<div class="highlight-python"><pre>UBRDIVn + (num of 1’s in UDIVSLOTn)/16 = (PCLK / (bps x 16 ) ) −1</pre>
</div>
<p>其中</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">PCLK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">533</span><span class="o">*</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span>
<span class="n">bps</span> <span class="o">=</span> <span class="mi">115200</span>
</pre></div>
</div>
<p>由此我们可以计算出</p>
<div class="highlight-python"><pre>UBRDIV0 + (num of 1’s in UDIVSLOT0)/16
    = ((553*10^6/8) / (115200*16)) - 1
    = 36.5027</pre>
</div>
<p>所以可以将UBRDIV0设置为36，即0x24,可将UDIVSLOT0设置为0xFF(这样它包含1的个数为8)。最终设置如下</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">UBRDIV0</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>
<span class="n">UDIVSLOT0</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">通过串口进行读写</p>
<p>涉及到UFSTAT0，URXH0和UTXH0这三个寄存器。</p>
<img alt="../_images/datasheet_uart_UFSTATn.png" src="../_images/datasheet_uart_UFSTATn.png" />
<p>最简单的方式是通过轮询UFSTAT0中相应的读写状态位，发送数据时，一旦检测到发送缓冲区为空，则可将发送的字符直接写入UTXH0寄存器即可，接收数据时，一旦检测到接收缓冲区有内容，则可直接读取URXH0寄存器即可。</p>
</li>
</ul>
</div>
<div class="section" id="sdram">
<h2><a class="toc-backref" href="#id46">内存SDRAM</a><a class="headerlink" href="#sdram" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id47">概述</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>这部分相对来说感觉是有点复杂的，除了参考内存和内存控制器的手册外，可能还需要一些背景知识，可google以下两篇文章来了解</p>
<ul class="simple">
<li>深入了解内存</li>
<li>高手进阶，终极内存技术指南——完整进阶版</li>
</ul>
<p>下面是tiny6410核心板电路图关于内存部分的截图</p>
<img alt="../_images/board_sdram.png" src="../_images/board_sdram.png" />
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id48">背景知识</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>tiny6410带有2个大小为128M的Mobile DDR SDRAM的内存，具体型号为K4X1G163PE-FGC6，内存控制器为pl340。内存控制器为CPU和内存之间的一个中介，当CPU访问某个内存地址时，它只需要与内存控制器交互，然后由内存控制器具体向内存发出地址以及读写命令。</p>
<p>每个内存内部分成了n个bank，每个bank可以理解为一个内存块，而每个bank内部类似于一个表格，由行地址和列地址组成，一个行地址和一个列地址可以寻址的内容称为内存的最小存储单元。从内存手册中可以看出我们的内存的分成了4个bank。对于bank的寻址是由BA0和BA1引脚完成的。</p>
<p>我们使用的内存的容量规格为 <tt class="docutils literal"><span class="pre">64M*16</span></tt> ，其中的16表示每个内存中最小存储单元的容量(单位是bit)，也就是位宽，即可以有16条数据线同时访问，而其中的64M表示存储单元的数量，所以每个内存的容量为64M*16bit=128MB。根据上面的描述我们还可以计算出每个bank中存储单元的数量为64M/4=16M。</p>
<p>Mobile DDR SDRAM的实现决定了它内部需要进行&#8221;刷新&#8221;，也就是所谓的&#8221;充电&#8221;，否则时间长了数据就会慢慢丢失。而刷新操作有2种方式，第一种是auto refresh，也就是自动刷新，这实际上是内存控制器自动刷新内存，第二种方式是self refresh，也就是内存自我刷新，比如在系统待机时，内存会进行自我刷新。</p>
<p>访问方式，分为顺序访问和突发访问，前者是指依次发送一系列行地址和列地址而进行的常规访问，而突发访问(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输所涉及到存储单元（列）的数量就是突发长度（Burst Lengths，简称BL）。只要指定起始列地址与突发长度，内存就会依次地自动对后面相应数量的存储单元进行读/写操作而不再需要控制器连续地提供列地址。</p>
<div class="section" id="id16">
<h4><a class="toc-backref" href="#id49">时间参数</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>tRAC</dt>
<dd>行存取时间，即激活RASh和数据最终出现在数据总线之间的时间</dd>
<dt>tCAC</dt>
<dd>列存取时间，即激活RASh和数据最终出现在数据总线之间的时间</dd>
<dt>tRCD (RAS to CAS delay)</dt>
<dd>在发送列读写命令时必须要与行有效命令有一个间隔，这个间隔被定义为
tRCD，即RAS to CAS Delay（RAS至CAS延迟）</dd>
<dt>tCAS</dt>
<dd>在CAS发出之后，仍要经过一定的时间才能有数据输出，从CAS与读取命令发
出到第一笔数据输出的这段时间，这就是tCAS，又被称为CL（CAS Latency，
CAS潜伏期）。由于CL只在读取时出现，所以CL又被称为读取潜伏期（RL，
Read Latency）。</dd>
<dt>tRP (row precharge)</dt>
<dd>在发出预充电命令之后，要经过一段时间才能允许发送RAS行有效命令打开新
的工作行，这个间隔被称为tRP（Precharge command Period，预充电有效周
期）。</dd>
<dt>tRAS (row active time)</dt>
<dd>tRAS is the minimum number of clock cycles needed to access a
certain row of data in RAM between the data request and the
precharge command. It&#8217;s known as active to precharge
delay. According to Mushkin.com, in practice for DDR SDRAM, this
should be set to at least tRCD + tCAS + 2 to allow enough time for
data to be streamed out. [1]. It stands for row address strobe
time.</dd>
<dt>tAC</dt>
<dd>从数据I/O总线上有数据输出之前的一个时钟上升沿开始，数据即已传向S-AMP，
也就是说此时数据已经被触发，经过一定的驱动时间最终传向数据I/O总线进行
输出，这段时间我们称之为tAC（Access Time from CLK，时钟触发后的访问时
间）。</dd>
<dt>tWR</dt>
<dd>为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR，Write
Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个
时钟周期或再多一点（时钟频率越高，tWR占用周期越多）。</dd>
</dl>
</div>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id50">初始化</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>初始化内存控制器的步骤如下</p>
<ol class="arabic">
<li><p class="first">将b100写入memc_cmd，使内存控制器进入&#8217;config&#8217;模式</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCCMD</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCCMD</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">内存控制器本身的初始化，包括设置内存的某些参数，比如刷新周期和各种时序参数等等</p>
<ul>
<li><p class="first">刷新周期设置</p>
<p>设置的刷新周期要以内存的时钟周期为单位，内存的时钟来自于HCLK，在之前的配置中可以知道HCLK为533/4MHz。从内存手册中看出刷新周期为7.8us，需要转换成内存的时钟周期。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define MEM_FREQUENCY    (533/4)</span>
<span class="c">#define ns2ck(ns)        (MEM_FREQUENCY * (ns) / 1000 + 1)</span>
<span class="n">P1REFRESH</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1REFRESH</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ns2ck</span><span class="p">(</span><span class="mi">7800</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p class="first">内存参数设置</p>
<p>设计到的寄存器包括P1MEMCFG、P1MEMCFG2。</p>
<p>首先先来设置P1MEMCFG，下面是它各个位的含义</p>
<img alt="../_images/datasheet_sdram_P1MEMCFG_1.png" src="../_images/datasheet_sdram_P1MEMCFG_1.png" />
<img alt="../_images/datasheet_sdram_P1MEMCFG_2.png" src="../_images/datasheet_sdram_P1MEMCFG_2.png" />
<ul>
<li><p class="first">行地址位数和列地址位数</p>
<p>下面是内存手册上的截图</p>
<img alt="../_images/sdram_address_conf.png" src="../_images/sdram_address_conf.png" />
<p>可以看出行地址位数和列地址位数分别为14位和10位:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">);</span>
<span class="n">P1MEMCFG</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
</pre></div>
</div>
<img alt="../_images/sdram_precharge_bit_conf.png" src="../_images/sdram_precharge_bit_conf.png" />
</li>
<li><p class="first">自动预充电位设置</p>
<p>自动预充电位为内存地址中的第10位:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">突发访问长度设置</p>
<p>对于突发访问的长度，内存手册上支持2、4、8、16，我们将其设置为4。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<p>接着我们来设置P1MEMCFG2，下面是它各个位的含义</p>
<img alt="../_images/datasheet_sdram_P1MEMCFG2.png" src="../_images/datasheet_sdram_P1MEMCFG2.png" />
<ul>
<li><p class="first">内存类型设置</p>
<p>我们内存类型设为Mobile DDR SDRAM:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG2</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">位宽设置</p>
<p>从开发板核心板原理图上可以看出，内存是由两块内存组合起来使用的，每个位16位，总共位宽为32位:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG2</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">其它设置</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCFG2</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
<span class="n">P1MEMCFG2</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
<span class="n">P1MEMCFG2</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCFG2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">时序设置</p>
<div class="highlight-python"><pre>P1CASLAT = setval(P1CASLAT, 0, 0, 0x0);
P1CASLAT = setval(P1CASLAT, 3, 1, 0x3);
P1T_DQSS = setval(P1T_DQSS, 1, 0, 0x1);
P1T_MRD  = setval(P1T_MRD, 6, 0, 0x2);
P1T_RAS  = setval(P1T_RAS, 3, 0, ns2ck(42));
P1T_RC   = setval(P1T_RC, 3, 0, ns2ck(60));
P1T_RCD  = setval(P1T_RCD, 2, 0, ns2ck(18));
P1T_RCD  = setval(P1T_RCD, 5, 3, ns2ck(18) - 3);
P1T_RFC  = setval(P1T_RFC, 4, 0, ns2ck(80));
P1T_RFC  = setval(P1T_RFC, 9, 5, ns2ck(80) - 3);
P1T_RP   = setval(P1T_RP, 2, 0, ns2ck(18));
P1T_RP   = setval(P1T_RP, 5, 3, ns2ck(18) - 3);
P1T_RRD  = setval(P1T_RRD, 3, 0, ns2ck(12));
P1T_WR   = setval(P1T_WR, 2, 0, ns2ck(12));
P1T_WTR  = setval(P1T_WTR, 2, 0, 0x2); /* ??? */
P1T_XP   = setval(P1T_XP, 7, 0, 0x2);  /* ??? */
P1T_XSR  = setval(P1T_XSR, 7, 0, ns2ck(120));
P1T_ESR  = setval(P1T_ESR, 7, 0, ns2ck(120)); /* ??? */</pre>
</div>
</li>
</ul>
</li>
<li><p class="first">执行内存初始化</p>
<p>内存初始化的配置代码根据内存类型的不同而不同，tiny6410的内存为 <tt class="docutils literal"><span class="pre">Mobile</span> <span class="pre">DDR</span> <span class="pre">SDRAM</span></tt> 类型，具体步骤如下:</p>
<p>注意:6410 datasheet上第5.4.3一节所使用的配置代码是错误的。</p>
<ol class="arabic simple">
<li>将b11写入direct_cmd，使内存控制器发出&#8217;NOP&#8217;内存命令。</li>
<li>将b00写入direct_cmd，使内存控制器发出&#8217;Prechargeall&#8217;内存命令。</li>
<li>将b01写入direct_cmd，使内存控制器发出&#8217;Autorefresh&#8217;内存命令。</li>
<li>将b01写入direct_cmd，使内存控制器发出&#8217;Autorefresh&#8217;内存命令。</li>
<li>将b10写入direct_cmd，使内存控制器发出&#8217;EMRS&#8217;内存命令。并且需要配置EMRS寄存器</li>
<li>将b10写入direct_cmd，使内存控制器发出&#8217;MRS&#8217;内存命令。并且需要配置MRS寄存器</li>
</ol>
<img alt="../_images/datasheet_sdram_PnDIRECTCMD.png" src="../_images/datasheet_sdram_PnDIRECTCMD.png" />
<p>代码如下</p>
<div class="highlight-python"><pre>P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x3); /* NOP */
P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x0); /* Prechargeall */
P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x1); /* Autorefresh */
P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x1); /* Autorefresh */

/* set EMRS and MRS, refer to K4X1G163PE-FGC6(8)_R11.pdf */

P1DIRECTCMD = 0xa0000;
P1DIRECTCMD = 0x80032;

MEM_SYS_CFG = 0;</pre>
</div>
<p>注意在设置EMRS和MRS时，不能分开赋值，上面代码中最后两条给P1DIRECTCMD赋值的语句不能写成如下形式，虽然表面看没有什么区别:</p>
<div class="highlight-python"><pre>P1DIRECTCMD = setval(P1DIRECTCMD, 17, 16, 0x2);      /* EMRS Bank Addr */
P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x2);   /* EMRS */
P1DIRECTCMD = setval(P1DIRECTCMD, 13, 0, 0x32);
P1DIRECTCMD = setval(P1DIRECTCMD, 17, 16, 0x0);   /* MRS Bank Addr */
P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x2);   /* MRS */</pre>
</div>
</li>
<li><p class="first">将b000写入memc_cmd，使内存控制器进入&#8217;go&#8217;模式</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P1MEMCCMD</span> <span class="o">=</span> <span class="n">setval</span><span class="p">(</span><span class="n">P1MEMCCMD</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">检测内存状态寄存器memc_stat直到表示内存的状态的值为b01，表明进入了&#8217;ready&#8217;状态</p>
<div class="highlight-python"><pre>while (getval(P1MEMSTAT, 1, 0) == 0x1)
    break;</pre>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="nandflash">
<h2><a class="toc-backref" href="#id51">硬盘NandFlash</a><a class="headerlink" href="#nandflash" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id52">概述</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<img alt="../_images/board_nand.png" src="../_images/board_nand.png" />
<p>这是nand flash的电路图。</p>
</div>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id53">背景知识</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<img alt="../_images/nand_organization.png" src="../_images/nand_organization.png" />
<p>整个nand flash由2076个块(block)组成，每个块(block)由128个页(page)组成，而每个页的大小为8K，读写的最小单位就是page。每一页附带有436字节的错误校验码，这部分属于另外的空间，不属于平时访问的nand flash地址空间，读取错误校验码需要使用特殊的读命令。另外，在访问nand flash时，块和页的地址合起来称为行(row)地址，而页内偏移地址又称为列(column)地址。</p>
<p>nand flash的地址、命令和数据传输共用同样的IO端口，有专门的引脚来指示当前传输的是地址、命令或者是数据。发送地址时，分多次发送，见上图。</p>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id54">初始化</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">时序设置</p>
<p>datasheet上需要设置三个时序，如下图所示:</p>
<img alt="../_images/datasheet_nand_time.png" src="../_images/datasheet_nand_time.png" />
<p>上面的时序图中的nWE和nRE都应该是低电平有效，图中错误。</p>
<img alt="../_images/datasheet_nand_time_register.png" src="../_images/datasheet_nand_time_register.png" />
<p>这是时序对应寄存器的各个位。</p>
<p>设置时序时涉及到nand flash的时钟，我们可以知道来自于HCLK，值为266MHz，换算后大约为3.76ns。</p>
<ul>
<li><p class="first">TACLS</p>
<p>这是从CLE/ALE变成有效之后，间隔多长时间WE变成有效，对应于nand flash手册中时序图(tCLS-tWP)和(tALS-tWP)这两个值中的较小的那个。tCLS、tALS和tWP都最小为15ns，所以这个值设为0或者1都可以。</p>
</li>
<li><p class="first">TWRPH0</p>
<p>这是WE和RE所持续的时间，对应于nand flash手册中时序图tWP和tRP这两个值中的较小的那个，这两个值都最小为15ns。而换算公式为:</p>
<div class="highlight-python"><pre>持续时间=HCLK*(TWRPH0+1)</pre>
</div>
<p>其中的持续时间最小为15ns，HCLK为3.76ns，所以TWRPH0设置为3或4或者更大的值都可以。由于对应的寄存器只有三位，所以最大为7。</p>
</li>
<li><p class="first">TWRPH1</p>
<p>这是WE和RE变成无效之后，CLE/ALE还持续多长时间，对应于nand flash手册中时序图tCLH和tALH这两个值中的较小的那个，这两个值都最小为5ns。而换算公式为:</p>
<div class="highlight-python"><pre>持续时间=HCLK*(TWRPH1+1)</pre>
</div>
<p>其中的持续时间最小为5ns，HCLK为3.76ns，所以TWRPH1设置为1即可。</p>
</li>
</ul>
<p>所以最终的时序设置如下:</p>
<div class="highlight-python"><pre>NFCONF = setval(NFCONF, 6, 4, 1);   /* TWRPH1 */
NFCONF = setval(NFCONF, 10, 8, 3);  /* TWRPH0 */
NFCONF = setval(NFCONF, 14, 12, 0); /* TACLS */</pre>
</div>
</li>
<li><p class="first">读写过程</p>
</li>
<li><p class="first">发送地址</p>
<p>向NFADDR寄存器里写入地址即可，但注意只有[7:0]位有效，要按照nand flash手册上写的步骤分5次发送，每次发送8位。因此发送一个32位的地址时需要将它拆分计算出每次发送的8位值。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="id21">
<h2><a class="toc-backref" href="#id55">中断和异常</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="mmu">
<h2><a class="toc-backref" href="#id56">MMU</a><a class="headerlink" href="#mmu" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="u-boot">
<h1><a class="toc-backref" href="#id57">u-boot移植</a><a class="headerlink" href="#u-boot" title="Permalink to this headline">¶</a></h1>
<p>所需参数</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ARCH</span>   <span class="o">=</span> <span class="n">arm</span>
<span class="n">CPU</span>    <span class="o">=</span> <span class="n">s3c64xx</span>
<span class="n">BOARD</span>  <span class="o">=</span> <span class="n">tiny6410</span>
<span class="n">VENDOR</span> <span class="o">=</span> <span class="n">samsung</span>
<span class="n">SOC</span>    <span class="o">=</span> <span class="n">s3c6410</span>
</pre></div>
</div>
<p>修改为</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ARCH</span>   <span class="o">=</span> <span class="n">arm</span>
<span class="n">CPU</span>    <span class="o">=</span> <span class="n">arm1176</span>
<span class="n">BOARD</span>  <span class="o">=</span> <span class="n">tiny6410</span>
<span class="n">VENDOR</span> <span class="o">=</span> <span class="n">samsung</span>
<span class="n">SOC</span>    <span class="o">=</span> <span class="n">s3c6410</span>
</pre></div>
</div>
<p>所涉及到的文件</p>
<div class="highlight-python"><pre>/board/arm/tiny6410/    # 在 config.h 中定义
/arch/arm/cpu/arm1176   # 未明确定义

# 在/mkconfig脚本中定义
if [ "${soc}" ] ; then
    # /arch/arm/include/asm/arch-s3c6410
    ln -s ${LNPREFIX}arch-${soc} asm/arch
elif [ "${cpu}" ] ; then
    # /arch/arm/include/asm/arch-arm1176
    ln -s ${LNPREFIX}arch-${cpu} asm/arch
fi</pre>
</div>
<p>对于最新版u-boot，使用make rpi_b_config后生成的文件</p>
<div class="highlight-python"><pre>if [ "${soc}" ] ; then
    ln -s ${LNPREFIX}arch-${soc} asm/arch
elif [ "${cpu}" ] ; then
    ln -s ${LNPREFIX}arch-${cpu} asm/arch
fi

/* Automatically generated - do not edit */
#define CONFIG_SYS_ARCH  "arm"
#define CONFIG_SYS_CPU   "arm1176"
#define CONFIG_SYS_BOARD "rpi_b"
#define CONFIG_SYS_VENDOR "raspberrypi"
#define CONFIG_SYS_SOC    "bcm2835"
#define CONFIG_BOARDDIR board/raspberrypi/rpi_b
#include &lt;config_cmd_defaults.h&gt;
#include &lt;config_defaults.h&gt;
#include &lt;configs/rpi_b.h&gt;
#include &lt;asm/config.h&gt;
#include &lt;config_fallbacks.h&gt;
#include &lt;config_uncmd_spl.h&gt;</pre>
</div>
</div>
<div class="section" id="id22">
<h1><a class="toc-backref" href="#id58">驱动程序开发</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id23">
<h2><a class="toc-backref" href="#id59">概述</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id60">主要文件介绍</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">/linux-3.10/arch/arm/plat-samsung/</p>
<p>三星SoC系统的公用代码</p>
</li>
<li><p class="first">/linux-3.10/arch/arm/mach-s3c64xx/</p>
<p>三星64xx系列SoC开发板的代码</p>
</li>
<li><p class="first">/linux-3.10/arch/arm/mach-s3c64xx/s3c6410.c</p>
<p>定义s3c6410 CPU通用的一些资源和函数，供./common.c使用</p>
<div class="highlight-python"><pre>static struct cpu_table cpu_ids[] __initdata = {
    {
        .idcode             = S3C6400_CPU_ID,
        .idmask             = S3C64XX_CPU_MASK,
        .map_io             = s3c6400_map_io,
        .init_clocks        = s3c6400_init_clocks,
        .init_uarts = s3c64xx_init_uarts,
        .init               = s3c6400_init,
        .name               = name_s3c6400,
    }, {
        .idcode             = S3C6410_CPU_ID,
        .idmask             = S3C64XX_CPU_MASK,
        .map_io             = s3c6410_map_io,
        .init_clocks        = s3c6410_init_clocks,
        .init_uarts = s3c64xx_init_uarts,
        .init               = s3c6410_init,
        .name               = name_s3c6410,
    },
};</pre>
</div>
</li>
<li><p class="first">/linux-3.10/arch/arm/mach-s3c64xx/common.c</p>
<p>定义s3c64xx开发板通用的一些资源和函数，供具体的板级文件使用，例如./mach-mini6410.c</p>
</li>
<li><p class="first">/linux-3.10/arch/arm/mach-s3c64xx/mach-mini6410.c</p>
<p>定义板级文件相关内容，包括主要的外设资源，以及开发板初始化等一些列操作，最后通过MACHINE_START和MACHINE_END宏将其定义到一个struct machine_desc结构中</p>
<div class="highlight-python"><pre>MACHINE_START(MINI6410, "MINI6410")
    /* Maintainer: Darius Augulis &lt;augulis.darius@gmail.com&gt; */
    .atag_offset    = 0x100,
    .init_irq       = s3c6410_init_irq,
    .map_io         = mini6410_map_io,
    .init_machine   = mini6410_machine_init,
    .init_late      = s3c64xx_init_late,
    .init_time      = samsung_timer_init,
    .restart        = s3c64xx_restart,
MACHINE_END</pre>
</div>
<ul>
<li><p class="first">platform设备</p>
<p>在此文件中定义了一个platform_device的数组</p>
<div class="highlight-python"><pre>static struct platform_device *mini6410_devices[] __initdata = {
    &amp;mini6410_device_eth,
    &amp;s3c_device_hsmmc0,
    &amp;s3c_device_hsmmc1,
    &amp;s3c_device_ohci,
    &amp;s3c_device_nand,
    &amp;s3c_device_fb,
    &amp;mini6410_lcd_powerdev,
    &amp;s3c_device_adc,
    &amp;s3c_device_ts,
};</pre>
</div>
</li>
</ul>
<blockquote>
<div><p>随后，在mini6410_machine_init()中将这些platform设备加入</p>
<div class="highlight-python"><pre>static void __init mini6410_machine_init(void)
{
    ...

    platform_add_devices(mini6410_devices, ARRAY_SIZE(mini6410_devices));
}</pre>
</div>
</div></blockquote>
<ul>
<li><p class="first">Nand Flash</p>
<p>Nand Flash分区信息</p>
<div class="highlight-python"><pre>static struct mtd_partition mini6410_nand_part[] = {
    [0] = {
        .name     = "uboot",
        .size     = SZ_1M,
        .offset   = 0,
    },
    [1] = {
        .name     = "kernel",
        .size     = SZ_2M,
        .offset   = SZ_1M,
    },
    [2] = {
        .name     = "rootfs",
        .size     = MTDPART_SIZ_FULL,
        .offset   = SZ_1M + SZ_2M,
    },
};</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id25">
<h3><a class="toc-backref" href="#id61">其他</a><a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>module_driver(__driver, __register, __unregister, ...)</p>
</div>
<div class="section" id="id26">
<h3><a class="toc-backref" href="#id62">辅助工具</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>sysfsutils
mtd-utils
usbutils</p>
</div>
</div>
<div class="section" id="id27">
<h2><a class="toc-backref" href="#id63">串口</a><a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id28">
<h3><a class="toc-backref" href="#id64">主要的数据结构</a><a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">uart driver</p>
<div class="highlight-python"><pre>struct uart_driver
int uart_register_driver(struct uart_driver *uart);
void uart_unregister_driver(struct uart_driver *uart);</pre>
</div>
</li>
<li><p class="first">uart port</p>
<div class="highlight-python"><pre>struct uart_port
int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);</pre>
</div>
</li>
<li><p class="first">uart ops</p>
<div class="highlight-python"><pre>struct uart_ops</pre>
</div>
</li>
<li><p class="first">console</p>
<div class="highlight-python"><pre>struct console</pre>
</div>
</li>
</ul>
</div>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id65">主要的操作</a><a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>定义在struct uart_ops中</p>
<div class="highlight-python"><pre>/*
 * This structure describes all the operations that can be done on the
 * physical hardware.  See Documentation/serial/driver for details.
 */
struct uart_ops {
      unsigned int    (*tx_empty)(struct uart_port *);
      void            (*set_mctrl)(struct uart_port *, unsigned int mctrl);
      unsigned int    (*get_mctrl)(struct uart_port *);
      void            (*stop_tx)(struct uart_port *);
      void            (*start_tx)(struct uart_port *);
      void            (*throttle)(struct uart_port *);
      void            (*unthrottle)(struct uart_port *);
      void            (*send_xchar)(struct uart_port *, char ch);
      void            (*stop_rx)(struct uart_port *);
      void            (*enable_ms)(struct uart_port *);
      void            (*break_ctl)(struct uart_port *, int ctl);
      int             (*startup)(struct uart_port *);
      void            (*shutdown)(struct uart_port *);
      void            (*flush_buffer)(struct uart_port *);
      void            (*set_termios)(struct uart_port *, struct ktermios *new,
                                     struct ktermios *old);
      void            (*set_ldisc)(struct uart_port *, int new);
      void            (*pm)(struct uart_port *, unsigned int state,
                            unsigned int oldstate);
      int             (*set_wake)(struct uart_port *, unsigned int state);

      /*
       * Return a string describing the type of the port
       */
      const char      *(*type)(struct uart_port *);

      /*
       * Release IO and memory resources used by the port.
       * This includes iounmap if necessary.
       */
      void            (*release_port)(struct uart_port *);

      /*
       * Request IO and memory resources used by the port.
       * This includes iomapping the port if necessary.
       */
      int             (*request_port)(struct uart_port *);
      void            (*config_port)(struct uart_port *, int);
      int             (*verify_port)(struct uart_port *, struct serial_struct *);
      int             (*ioctl)(struct uart_port *, unsigned int, unsigned long);
#ifdef CONFIG_CONSOLE_POLL
      int             (*poll_init)(struct uart_port *);
      void            (*poll_put_char)(struct uart_port *, unsigned char);
      int             (*poll_get_char)(struct uart_port *);
#endif
};</pre>
</div>
<ul>
<li><p class="first">数据发送</p>
<p>数据保存在struct circ_buf中</p>
<ul class="simple">
<li>pull模式</li>
<li>利用中断的数据发送</li>
</ul>
</li>
<li><p class="first">数据接收</p>
</li>
<li><p class="first">modem控制线</p>
</li>
<li><p class="first">termios</p>
</li>
<li><p class="first">console</p>
</li>
</ul>
</div>
</div>
<div class="section" id="nand-flash">
<h2><a class="toc-backref" href="#id66">Nand Flash</a><a class="headerlink" href="#nand-flash" title="Permalink to this headline">¶</a></h2>
<p>struct mtd_part</p>
<blockquote>
<div>表示分区信息</div></blockquote>
<p>add_mtd_partitions()
del_mtd_partitions()</p>
<p>add_mtd_device()
del_mtd_device()</p>
</div>
<div class="section" id="usb">
<h2><a class="toc-backref" href="#id67">USB</a><a class="headerlink" href="#usb" title="Permalink to this headline">¶</a></h2>
<p>struct usb_string_descriptor
struct usb_endpoint_descriptor
struct usb_interface_descriptor
struct usb_config_descriptor
struct usb_device_descriptor</p>
<p>struct usb_hcd
struct hc_driver</p>
</div>
<div class="section" id="network">
<h2><a class="toc-backref" href="#id68">Network</a><a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="platform">
<h2><a class="toc-backref" href="#id69">Platform</a><a class="headerlink" href="#platform" title="Permalink to this headline">¶</a></h2>
<p>6410中的platform驱动包括：I2C、LCD、看门狗等</p>
<p>主要的数据结构</p>
<p>struct platform_device</p>
<blockquote>
<div>包括设备名、资源等信息</div></blockquote>
<p>struct platform_driver</p>
<blockquote>
<div><p>包括各种操作，例如probe remove等</p>
<div class="highlight-python"><pre>int platform_device_add(struct platform_device *pdev)
void platform_device_del(struct platform_device *pdev)
int platform_device_register(struct platform_device *pdev)
void platform_device_unregister(struct platform_device *pdev)</pre>
</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">嵌入式系统笔记</a><ul>
<li><a class="reference internal" href="#id2">概述</a></li>
<li><a class="reference internal" href="#id3">嵌入式开发环境设置</a><ul>
<li><a class="reference internal" href="#id4">交叉编译环境设置</a></li>
<li><a class="reference internal" href="#id5">调试工具设置</a></li>
<li><a class="reference internal" href="#id6">关于调试工具的疑难问题</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">编写裸机代码时需要做的准备工作</a><ul>
<li><a class="reference internal" href="#arm">ARM汇编</a></li>
<li><a class="reference internal" href="#id8">其它</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">学习计划</a></li>
<li><a class="reference internal" href="#id10">参考资料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">各子系统裸机开发笔记</a><ul>
<li><a class="reference internal" href="#id12">系统初始化</a></li>
<li><a class="reference internal" href="#led">LED</a></li>
<li><a class="reference internal" href="#id13">时钟</a></li>
<li><a class="reference internal" href="#uart">串口UART</a></li>
<li><a class="reference internal" href="#sdram">内存SDRAM</a><ul>
<li><a class="reference internal" href="#id14">概述</a></li>
<li><a class="reference internal" href="#id15">背景知识</a><ul>
<li><a class="reference internal" href="#id16">时间参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">初始化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nandflash">硬盘NandFlash</a><ul>
<li><a class="reference internal" href="#id18">概述</a></li>
<li><a class="reference internal" href="#id19">背景知识</a></li>
<li><a class="reference internal" href="#id20">初始化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">中断和异常</a></li>
<li><a class="reference internal" href="#mmu">MMU</a></li>
</ul>
</li>
<li><a class="reference internal" href="#u-boot">u-boot移植</a></li>
<li><a class="reference internal" href="#id22">驱动程序开发</a><ul>
<li><a class="reference internal" href="#id23">概述</a><ul>
<li><a class="reference internal" href="#id24">主要文件介绍</a></li>
<li><a class="reference internal" href="#id25">其他</a></li>
<li><a class="reference internal" href="#id26">辅助工具</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id27">串口</a><ul>
<li><a class="reference internal" href="#id28">主要的数据结构</a></li>
<li><a class="reference internal" href="#id29">主要的操作</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nand-flash">Nand Flash</a></li>
<li><a class="reference internal" href="#usb">USB</a></li>
<li><a class="reference internal" href="#network">Network</a></li>
<li><a class="reference internal" href="#platform">Platform</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/sources/embeddedsystem.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">funexploit 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, jff.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>