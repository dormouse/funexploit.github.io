=================
linux驱动开发笔记
=================

.. contents::


为了学习linux驱动和内核的开发，买了块友善tiny6410的板子，开始了嵌入式系统的学习。本文是我在学习过程中的笔记，会随着自己的学习持续更新，文章如有错误，敬请指正。

另外寻求有兴趣的朋友一起学习折腾、实时交流心得体会和问题。 `funexploit # aliyun.com <funexploit # aliyun.com>`_

开发环境搭建
============

主机为 ubuntu ，开发板为 tiny6410 ，在驱动开发过程中通过串口和网线连接主机和开发板。

在主机上开启 tftp 服务和 NFS 服务，然后设置好 u-boot，通过 tftp 将内核加载到开发板 sdram 中，然后启动内核，再通过 NFS 挂载主机上的根文件系统。这样可以加速驱动的开发。

串口通信工具kermit配置
----------------------

安装

::

   aptitude install ckermit

创建kermit配置文件/root/.kermrc

::

  set line /dev/ttyUSB0
  set speed 115200
  set carrier-watch off
  set handshake none
  set flow-control none
  robust
  set file type bin
  set file name lit
  set rec pack 1000
  set send pack 1000
  set window 5
  c

tftp服务配置
------------

安装

::

   aptitude install tftpd-hpa

创建 tftpd 根目录

::

   mkdir /tftproot

修改配置文件 `/etc/inetd.conf` 添加以下内容

::

   tftp dgram udp wait root /usr/sbin/tcpd /usr/sbin/in.tftpd -s /tftproot

由于 tftp 服务是由 inetd 服务管理的，我们需要将 inetd 服务设置为随系统启动

::

   update-rc.d openbsd-inetd defaults

重新启动系统，这一步必不可少。然后将 zImage 复制到 /tftproot 下即可。

NFS服务配置
-----------

安装

::

   aptitude install nfs-server

修改配置文件 `/etc/exports` 添加以下内容

::

   /home/forfun/pro/7.embeddedsystem/rootfs/ *(async,rw,no_root_squash,anonuid=0,anongid=0,no_subtree_check)

添加服务随系统运行

::

   update-rc.d nfs-kernel-server defaults

u-boot设置
----------

设置IP地址相关的环境变量，将 u-boot 的 ip 设置为 192.168.2.101，ubuntu 主机为 192.168.2.100

::

   setenv ipaddr 192.168.2.101
   setenv serverip 192.168.2.100

设置环境变量通过tftp加载内核并运行

::

   setenv bootcmd 'tftpboot 0xc0008000 zImage; bootm 0xc0008000'

设置环境变量通过NFS加载主机上的根文件系统

::

   setenv bootargs 'console=ttySAC0 root=/dev/nfs nfsroot=192.168.2.100:/home/forfun/pro/7.embeddedsystem/rootfs/rootfs_qtopia_qt4,proto=tcp,nolock ip=192.168.2.102:192.168.2.100:192.168.2.100:255.255.255.0:mini6410:eth0:off`

保存刚才设置的所有环境变量并重启

::

   saveenv
   reset

安装内核文档
------------

在内核根目录下用root权限执行以下命令

::

   make installmandocs

会将内核的 man 手册安装到 /usr/local/man/man9/


遇到的疑难杂症
--------------

- 使用下载的交叉编译工具，运行时提示"No such file or directory"

  由于使用的是64位的系统，而交叉编译工具是32位的，需要安装几个库文件

  ::

     aptitude install lib32ncurses5 lib32z1 lib32bz2-1.0

- 通过NFS挂载根系统时，提示"can't open /r/dev/console: no such file"

  禁用内核中下面的选项即可

  ::

    CONFIG_BLK_DEV_INITRD:

    The initial RAM filesystem is a ramfs which is loaded by the
    boot loader (loadlin or lilo) and that is mounted as root
    before the normal boot procedure. It is typically used to
    load modules needed to mount the "real" root file system,
    etc. See <file:Documentation/initrd.txt> for details.

    If RAM disk support (BLK_DEV_RAM) is also included, this
    also enables initial RAM disk (initrd) support and adds
    15 Kbytes (more on some other architectures) to the kernel size.

    If unsure say Y.

    Symbol: BLK_DEV_INITRD [=n]
    Type  : boolean
    Prompt: Initial RAM filesystem and RAM disk (initramfs/initrd) support
      Defined at init/Kconfig:865
      Depends on: BROKEN [=n] || !FRV
      Location:
        -> General setup

概述
====

驱动底层封装接口
----------------

内核中有很多函数，封装了对底层寄存器的操作。

- arch/arm/plat-samsung/include/plat/gpio-cfg.h

  s3c_gpio_cfgpin()

  s3c_irq_eint_set_type

- include/linux/gpio.h

  + gpio_direction_input()
  + gpio_direction_output()

- arch/arm/mach-s3c64xx/include/mach/gpio.h

  寄存器不需要自己一个一个去remap()，内核中已经有现成的包装好的接口，例如 ``S3C64XX_GPN(0)``

  + gpio_get_value()
  + gpio_set_value()
  + gpio_cansleep()
  + gpio_to_irq()

参考

  http://blog.sina.com.cn/s/blog_3c70fb610100mufi.html

驱动程序结构
------------

- file_operations

- devno

  alloc_chrdev_region
  unregister_chrdev_region

- cdev

  cdev_init
  cdev_add
  cdev_del

- class, device

  class_create
  class_destroy
  device_create
  device_destroy

主要文件介绍
------------

* /linux-3.10/arch/arm/plat-samsung/

  三星SoC系统的公用代码

* /linux-3.10/arch/arm/mach-s3c64xx/

  三星64xx系列SoC开发板的代码

* /linux-3.10/arch/arm/mach-s3c64xx/s3c6410.c

  定义s3c6410 CPU通用的一些资源和函数，供./common.c使用

  ::

    static struct cpu_table cpu_ids[] __initdata = {
        {
            .idcode		= S3C6400_CPU_ID,
            .idmask		= S3C64XX_CPU_MASK,
            .map_io		= s3c6400_map_io,
            .init_clocks	= s3c6400_init_clocks,
            .init_uarts	= s3c64xx_init_uarts,
            .init		= s3c6400_init,
            .name		= name_s3c6400,
        }, {
            .idcode		= S3C6410_CPU_ID,
            .idmask		= S3C64XX_CPU_MASK,
            .map_io		= s3c6410_map_io,
            .init_clocks	= s3c6410_init_clocks,
            .init_uarts	= s3c64xx_init_uarts,
            .init		= s3c6410_init,
            .name		= name_s3c6410,
        },
    };

* /linux-3.10/arch/arm/mach-s3c64xx/common.c

  定义s3c64xx开发板通用的一些资源和函数，供具体的板级文件使用，例如./mach-mini6410.c

* /linux-3.10/arch/arm/mach-s3c64xx/mach-mini6410.c

  定义板级文件相关内容，包括主要的外设资源，以及开发板初始化等一些列操作，最后通过MACHINE_START和MACHINE_END宏将其定义到一个struct machine_desc结构中

  ::

    MACHINE_START(MINI6410, "MINI6410")
        /* Maintainer: Darius Augulis <augulis.darius@gmail.com> */
        .atag_offset	= 0x100,
        .init_irq	= s3c6410_init_irq,
        .map_io		= mini6410_map_io,
        .init_machine	= mini6410_machine_init,
        .init_late	= s3c64xx_init_late,
        .init_time	= samsung_timer_init,
        .restart	= s3c64xx_restart,
    MACHINE_END


  - platform设备

    在此文件中定义了一个platform_device的数组

    ::

      static struct platform_device *mini6410_devices[] __initdata = {
          &mini6410_device_eth,
          &s3c_device_hsmmc0,
          &s3c_device_hsmmc1,
          &s3c_device_ohci,
          &s3c_device_nand,
          &s3c_device_fb,
          &mini6410_lcd_powerdev,
          &s3c_device_adc,
          &s3c_device_ts,
      };

   随后，在mini6410_machine_init()中将这些platform设备加入

   ::

     static void __init mini6410_machine_init(void)
     {
         ...

         platform_add_devices(mini6410_devices, ARRAY_SIZE(mini6410_devices));
     }

  - Nand Flash

    Nand Flash分区信息

    ::

      static struct mtd_partition mini6410_nand_part[] = {
          [0] = {
              .name	= "uboot",
              .size	= SZ_1M,
              .offset	= 0,
          },
          [1] = {
              .name	= "kernel",
              .size	= SZ_2M,
              .offset	= SZ_1M,
          },
          [2] = {
              .name	= "rootfs",
              .size	= MTDPART_SIZ_FULL,
              .offset	= SZ_1M + SZ_2M,
          },
      };

其他
----

module_driver(__driver, __register, __unregister, ...)

应用层辅助工具
--------------

fbset
sysfsutils
mtd-utils
usbutils

设备驱动模型及子系统
====================

bus-device-driver 设备驱动模型
------------------------------

Platform 虚拟总线
-----------------

6410中的platform驱动包括：I2C、LCD、看门狗等

主要的数据结构

struct platform_device

  包括设备名、资源等信息

struct platform_driver

  包括各种操作，例如probe remove等

  ::

    int platform_device_add(struct platform_device *pdev)
    void platform_device_del(struct platform_device *pdev)
    int platform_device_register(struct platform_device *pdev)
    void platform_device_unregister(struct platform_device *pdev)



输入子系统
----------

视频子系统(framebuffer)
-----------------------

参考：Documentation/fb/framebuffer.txt

物理显示设备的工作原理如下：显示屏可以看作由一个一个像素组成，在显示的时候可以理解为向某个像素绘制某种颜色，整个屏幕的绘制顺序是从左到右，然后移动到下一行的行首，如此往复。绘制完整个屏幕之后，会跳回到屏幕的左上角。从上一行的行尾到下一行的行首所需时间被称为(horizontal retrace)，绘制完一屏后，从屏的右下角到左上角所需时间被称为(vertical retrace)。

屏幕的横纵分辨率分别被称为xres和yres。物理设备绘制的大小比实际的屏幕大，多出来的部分上下左右分别被称为upper margin, lower margin,left margin和right margin。另外，显示器并不知道什么时候开始一个新行，而是由一个行同步脉冲(horizontal sync或者简称为hsync)告诉它何时开始新行，hsync持续时间称为hsync len。同理，由列同步脉冲(vertical sync或者简称为vsync)告诉它何时从左上角开始绘制一个新屏(frame)，vsync持续时间称为vsync len。

.. image:: ./img/driver_framebuffer.png

..
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |upper_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------###############################################----------+-------+
     |          #                ↑                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |   left   #                |                            #  right   | hsync |
     |  margin  #                |       xres                 #  margin  |  len  |
     |<-------->#<---------------+--------------------------->#<-------->|<----->|
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |yres                        #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                ↓                            #          |       |
     +----------###############################################----------+-------+
     |          |                ↑                            |          |       |
     |          |                |lower_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |vsync_len                   |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+

从上图可以看出

::

  horizontal retrace = left margin  + right margin + hsync len
  vertical   retrace = upper margin + lower margin + vsync len

在编写驱动程序时，最主要的工作之一就是配置显示设备的物理参数，可以使用用户层命令fbset获得。

::

  mode "480x272-501595"
      # D: 76923.077 MHz, H: 145964.093 kHz, V: 501594.821 Hz
      geometry 480 272 480 272 16
      timings 13 40 5 9 8 2 2
      accel false
      rgba 5/11,6/5,5/0,0/0
  endmode


绘制每个像素的时间称为dotclock(单位是ps，即 picoseconds，1 s = 10^12 ps)。

在fbset命令的输出中D、H、V代表分别绘制一个像素、一行和一屏的频率。

geometry行分别表示可视水平分辨率(visible horizontal resolution，即xres)、可视垂直分辨率(visible vertical resolution，即yres)、虚拟水平分辨率(virtual horizontal resolution)、虚拟垂直分辨率(virtual vertical resolution)，以及颜色深度值，即每个像素需要几bit来表示。

timings行分别表示dotclock, left margin, right margin, upper margin, lower margin, hsync len 和 vsync len，单位是ps。

可以使用上面的知识，由geometry和timings的内容计算出D、H和V的值，验证fbset的输出，计算过程如下

::

  D = 1 / dotclock
    = 1 / (13 ps)
    = 76923.0769 MHz

  H = 1 / (dotclock * (xres + horizontal retrace))
    = 1 / (dotclock * (xres + left_margin + right_margin + hsync+len))
    = 1 / (dotclock * (480  + 40          + 5            + 2        ))
    = 1 / (13 ps    * 527 pixels)
    = 145964.093 KHz

  V = 1 / (dotclock * (xres + horizontal retrace) * (yres + vertical retrace))
    = 1 / (dotclock * (xres + left_margin  + right_margin + hsync+len)
                    * (yres + upper_margin + lower_margin + vsync+len))
    = 1 / (dotclock * (480  + 40           + 5            + 2)
                    * (272  + 9            + 8            + 2))
    = 1 / (13 ps * (527 * 291) pixel)
    = 501594.821 Hz



..
   Generic gpio library
   --------------------

   LED
   ---

   leds-gpio
   ~~~~~~~~~

   Generic input layer
   -------------------

   gpio_keys
   ~~~~~~~~~~~~~~~

存储技术设备子系统(mtd)
-----------------------

概述
~~~~

(此处只讨论nand flash类型的驱动)

mtd子系统为访问闪存设备提供抽象，mtd子系统在内核中从上到下可以分为以下几层：

- mtd字符设备接口、mtd块设备接口
- mtd核心层
- flash核心层
- falsh硬件驱动层

1. mtd字符设备接口、mtd块设备接口

   mtd字符设备接口将mtd设备映射为字符设备，对应的设备节点为 /dev/mtdN，可以使用字符设备的接口对其进行操作。源文件文件为

   ::

     drivers/mtd/mtdchar.c

   mtd块设备接口将mtd设备映射为块设备，对应的设备节点为 /dev/mtdblockN，可以使用块设备的接口对其进行操作。对应的文件为

   ::

     drivers/mtd/mtdblock.c

2. mtd核心层

   mtd核心层不必了解具体的flash类型(nor、nand或者onenand等等)，可以向上提供统一的接口。

   对应的文件为

   ::

     drivers/mtd/mtdcore.c
     drivers/mtd/mtdsuper.c
     drivers/mtd/mtdpart.c
     drivers/mtd/ofpart.c

3. flash核心层

   这是在mtd核心层下面的又一层抽象，针对具体的不同类型的flash硬件(nor、nand或者onenand等等)，实现flash类型相关的一些通用的功能。

   nand flash核心层对应的文件为

   ::

     drivers/mtd/nand/nand_base.c
     drivers/mtd/nand/nand_bbt.c
     drivers/mtd/nand/nand_ecc.c
     drivers/mtd/nand/nand_ids.c
     drivers/mtd/nand/sm_common.c

4. falsh硬件驱动层

   针对具体的不同型号的flash硬件实现的驱动程序，我们要实现的就是这一层的驱动。nand flash硬件驱动层源代码位于 drivers/mtd/nand/ 目录下。

主要的数据结构和操作
~~~~~~~~~~~~~~~~~~~~

::

   struct mtd_info         最主要的 mtd 结构体， 包含 mtd 设备的通用信息
   struct mtd_part         分区信息(mtd 内部使用)    ?
   struct mtd_partition    分区信息(驱动开发者使用)  ?
   struct nand_chip        具体的 nand flash 硬件相关的信息及操作函数

   struct platform_nand_data {
   struct platform_nand_chip chip;
   struct platform_nand_ctrl ctrl;
   };
   struct platform_nand_chip
   struct platform_nand_ctrl

nand flash驱动的主要工作
~~~~~~~~~~~~~~~~~~~~~~~~

参考内核中通用的 SoC Nand Flash 驱动程序 drivers/mtd/nand/plat_nand.c 。

- platform driver 部分需要完成的工作

  1. 使用 request_mem_region() 预留内存地址空间，并使用 ioremap() 映射内存
  #. 定义并分配 struct mtd_info 和 struct nand_chip，并将 mtd_info->priv 指向 nand_chip
  #. 使用 platform device定义的各种硬件相关的操作函数，给 nand_chip 赋值
  #. 用 nand_scan(mtd_info, nand_chip->nr_chips) 探测 nand flash
  #. 用 parse_mtd_partitions() 解析分区信息，然后用 add_mtd_partitions() 添加分区
  #. 最后用 add_mtd_device(mtd_info) 添加 mtd 设备

- platform device 部分需要完成的工作

  1. 定义 struct mtd_partition 结构体数组，其中包含 nand flash 的分区信息
  #. 定义 struct resource 结构体数组，其中包含将 nand flash 映射成的对应的内存地址
  #. 定义硬件相关的各种操作函数(需要在 platform driver 部分赋值给 nand_chip)

遇到的问题
~~~~~~~~~~

使用友善之臂提供的内核中，nand flash 驱动并不是开源的，与内核配置文件 drivers/mtd/nand/Kconfig 中的 MTD_NAND_S3C 选项没有关系，即与 drivers/mtd/nand/s3c_nand.c 文件无关。

它是通过在 drivers/mtd/nand/Makefile 末尾添加了几行来实现

::

  S3C_NAND_MLC_SRC = $(shell ls drivers/mtd/nand/s3c_nand_mlc.c 2>/dev/null)
  ifeq ($(S3C_NAND_MLC_SRC),)
  obj-$(CONFIG_MTD_NAND_S3C)			+= s3c_nand_mlc.fo
  else
  obj-$(CONFIG_MTD_NAND_S3C)			+= s3c_nand_mlc.o
  endif

想禁用它的驱动程序，将其注释掉即可。注意在 Kconfig 文件中没有相应的选项，与 BSP 中关于 nand flash 的内容也不相关。

参考

- Linux内核中NAND Flash坏块管理
  http://blog.csdn.net/linux_xiaomugua/article/details/7529348
- linux内核中对nand的坏块管理
  http://blog.csdn.net/haomcu/article/details/8181622
- bbt坏块管理
  http://blog.chinaunix.net/uid-22028566-id-1803151.html
- 硬件ECC
  http://www.360doc.com/content/14/0918/14/18578054_410432848.shtml
- nand flash坏块管理OOB,BBT,ECC
  http://www.cnblogs.com/elect-fans/archive/2012/05/14/2500643.html

网卡驱动
--------

struct sk_buff
struct net_device


内核机制
========

内核定时器
----------

休眠与唤醒
----------

中断
----

- include/linux/interrupt.h

  + 注册中断、释放中断

    ::

      request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
              const char *name, void *dev);

      void free_irq(unsigned int, void *);

  + 触发方式：上升沿、下降沿、高电平、低电平

    ::

      #define IRQF_TRIGGER_RISING	0x00000001
      #define IRQF_TRIGGER_FALLING	0x00000002
      #define IRQF_TRIGGER_HIGH	0x00000004
      #define IRQF_TRIGGER_LOW	0x00000008

异步通知
--------

驱动测试程序需要做的：

1. 将当前进程设置为设备文件的"属主"进程。通过使用fcntl的F_SETOWN参数设置，将进程号保存在filp->f_owner中。
2. 针对打开的驱动的设备文件，设置FASYNC标志。

驱动程序需要做的：

1. 在驱动测试程序设置F_SETOWN时，对filp->f_owner赋值。这一步会自动完成，驱动中不需要添加额外的代码。
2. 实现struct file_operations中的fasync调用，在fasync函数中通过内核提供的fasync_helper()来响应测试程序设置的FASYNC标志。
3. 数据达到时，使用kill_fasync()，向注册的"属主"进程发送SIGIO信号。
4. 在struct file_operations的release函数中，明确使用.fasync(-1, filp, 0)从异步通知列表中移除filp。

..
   硬件设备驱动程序开发
   ====================

   串口
   ----

   主要的数据结构
   ~~~~~~~~~~~~~~

   * uart driver

     ::

       struct uart_driver
       int uart_register_driver(struct uart_driver *uart);
       void uart_unregister_driver(struct uart_driver *uart);

   * uart port

     ::

       struct uart_port
       int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
       int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);

   * uart ops

     ::

       struct uart_ops

   * console

     ::

       struct console

   主要的操作
   ~~~~~~~~~~

   定义在struct uart_ops中

   ::

     /*
      * This structure describes all the operations that can be done on the
      * physical hardware.  See Documentation/serial/driver for details.
      */
     struct uart_ops {
       unsigned int	(*tx_empty)(struct uart_port *);
       void		(*set_mctrl)(struct uart_port *, unsigned int mctrl);
       unsigned int	(*get_mctrl)(struct uart_port *);
       void		(*stop_tx)(struct uart_port *);
       void		(*start_tx)(struct uart_port *);
       void		(*throttle)(struct uart_port *);
       void		(*unthrottle)(struct uart_port *);
       void		(*send_xchar)(struct uart_port *, char ch);
       void		(*stop_rx)(struct uart_port *);
       void		(*enable_ms)(struct uart_port *);
       void		(*break_ctl)(struct uart_port *, int ctl);
       int		(*startup)(struct uart_port *);
       void		(*shutdown)(struct uart_port *);
       void		(*flush_buffer)(struct uart_port *);
       void		(*set_termios)(struct uart_port *, struct ktermios *new,
                          struct ktermios *old);
       void		(*set_ldisc)(struct uart_port *, int new);
       void		(*pm)(struct uart_port *, unsigned int state,
                     unsigned int oldstate);
       int		(*set_wake)(struct uart_port *, unsigned int state);

       /*
        * Return a string describing the type of the port
        */
       const char	*(*type)(struct uart_port *);

       /*
        * Release IO and memory resources used by the port.
        * This includes iounmap if necessary.
        */
       void		(*release_port)(struct uart_port *);

       /*
        * Request IO and memory resources used by the port.
        * This includes iomapping the port if necessary.
        */
       int		(*request_port)(struct uart_port *);
       void		(*config_port)(struct uart_port *, int);
       int		(*verify_port)(struct uart_port *, struct serial_struct *);
       int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
     #ifdef CONFIG_CONSOLE_POLL
       int		(*poll_init)(struct uart_port *);
       void		(*poll_put_char)(struct uart_port *, unsigned char);
       int		(*poll_get_char)(struct uart_port *);
     #endif
     };

   * 数据发送

     数据保存在struct circ_buf中

     - pull模式
     - 利用中断的数据发送

   * 数据接收

   * modem控制线

   * termios

   * console

   Nand Flash
   ----------

   struct mtd_part

     表示分区信息

   add_mtd_partitions()
   del_mtd_partitions()

   add_mtd_device()
   del_mtd_device()

   USB
   ---

   struct usb_string_descriptor
   struct usb_endpoint_descriptor
   struct usb_interface_descriptor
   struct usb_config_descriptor
   struct usb_device_descriptor

   struct usb_hcd
   struct hc_driver

   Network
   -------

   LCD硬件相关
   ~~~~~~~~~~~

   - 信号

     VSYNC         垂直方向同步信号(vertical sync)
     HSYNC         水平方向同步信号(horizontal sync)
     VDEN          (video data enable)
     VCLK          时钟信号(video clock)
     LED+、LED-    背光信号
     VD0-VD23      RGB信号(video data)

   - 配置

     bpp(bit per pixel)
