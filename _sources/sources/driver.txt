=================
linux驱动开发笔记
=================

.. contents::


为了学习linux驱动和内核的开发，买了块友善tiny6410的板子，开始了嵌入式系统的学习。本文是我在学习过程中的笔记，会随着自己的学习持续更新，文章如有错误，敬请指正。

另外寻求有兴趣的朋友一起学习折腾、实时交流心得体会和问题。 `funexploit # gmail.com <funexploit # gmail.com>`_

开发环境搭建
============

- kermit

  创建kermit配置文件/root/.kermrc

  ::

    set line /dev/ttyUSB0
    set speed 115200
    set carrier-watch off
    set handshake none
    set flow-control none
    robust
    set file type bin
    set file name lit
    set rec pack 1000
    set send pack 1000
    set window 5
    c

- tftp服务

- nfs服务

- u-boot设置

根文件系统构建
--------------

busybox
~~~~~~~

1. make defconfig
2. 修改 .config 文件中两个地方

   # 编译器前缀
   CONFIG_CROSS_COMPILER_PREFIX="arm-linux-"

   # 安装路径，指定为NFS挂载的rootfs根目录
   CONFIG_PREFIX="./_install"
3. make
4. make install

根文件系统其它必须文件
~~~~~~~~~~~~~~~~~~~~~~

::

  mkdir dev etc mnt proc root sys tmp

参考 busybox/docs/mdev.txt 构建 /dev 。

- /etc/inittab

  参考 busybox/examples/inittab

  将其中的 "::askfirst:-/bin/sh" 改为 "ttySAC0::askfirst:-/bin/sh" ，以便在串口上输出。

- /etc/init.d/rcS

  ::

    ifconfig eth0 192.168.2.102
    mount -a
    mkdir /dev/pts
    mount -t devpts devpts /dev/pts
    echo /sbin/mdev > /proc/sys/kernel/hotplug
    mdev -s

  然后需要开启执行权限

  ::

    chmod +x /etc/init.d/rcS

- /etc/fatab

  ::

    proc    /proc   proc    defaults        0       0
    tmpfs   /tmp    tmpfs   defaults        0       0
    sysfs   /sys    sysfs   defaults        0       0
    tmpfs   /dev    tmpfs   defaults        0       0

- /etc/mdev.conf

  参考 busybox/examples/mdev.conf

遇到的疑难杂症
--------------

- 使用下载的交叉编译工具，运行时提示"No such file or directory"

  由于使用的是64位的系统，而下载的是32位的，需要安装几个库文件

  ::

     aptitude install lib32ncurses5 lib32z1 lib32bz2-1.0

- 通过NFS挂载根系统时，提示"can't open /r/dev/console: no such file"

  禁用内核中下面的选项即可

  ::

    CONFIG_BLK_DEV_INITRD:

    The initial RAM filesystem is a ramfs which is loaded by the
    boot loader (loadlin or lilo) and that is mounted as root
    before the normal boot procedure. It is typically used to
    load modules needed to mount the "real" root file system,
    etc. See <file:Documentation/initrd.txt> for details.

    If RAM disk support (BLK_DEV_RAM) is also included, this
    also enables initial RAM disk (initrd) support and adds
    15 Kbytes (more on some other architectures) to the kernel size.

    If unsure say Y.

    Symbol: BLK_DEV_INITRD [=n]
    Type  : boolean
    Prompt: Initial RAM filesystem and RAM disk (initramfs/initrd) support
      Defined at init/Kconfig:865
      Depends on: BROKEN [=n] || !FRV
      Location:
        -> General setup

概述
====

驱动底层封装接口
----------------

内核中有很多函数，封装了对底层寄存器的操作。

- arch/arm/plat-samsung/include/plat/gpio-cfg.h

  s3c_gpio_cfgpin()

  s3c_irq_eint_set_type

- include/linux/gpio.h

  + gpio_direction_input()
  + gpio_direction_output()

- arch/arm/mach-s3c64xx/include/mach/gpio.h

  寄存器不需要自己一个一个去remap()，内核中已经有现成的包装好的接口，例如 ``S3C64XX_GPN(0)``

  + gpio_get_value()
  + gpio_set_value()
  + gpio_cansleep()
  + gpio_to_irq()

参考

  http://blog.sina.com.cn/s/blog_3c70fb610100mufi.html

驱动程序结构
------------

- file_operations

- devno

  alloc_chrdev_region
  unregister_chrdev_region

- cdev

  cdev_init
  cdev_add
  cdev_del

- class, device

  class_create
  class_destroy
  device_create
  device_destroy

主要文件介绍
------------

* /linux-3.10/arch/arm/plat-samsung/

  三星SoC系统的公用代码

* /linux-3.10/arch/arm/mach-s3c64xx/

  三星64xx系列SoC开发板的代码

* /linux-3.10/arch/arm/mach-s3c64xx/s3c6410.c

  定义s3c6410 CPU通用的一些资源和函数，供./common.c使用

  ::

    static struct cpu_table cpu_ids[] __initdata = {
        {
            .idcode		= S3C6400_CPU_ID,
            .idmask		= S3C64XX_CPU_MASK,
            .map_io		= s3c6400_map_io,
            .init_clocks	= s3c6400_init_clocks,
            .init_uarts	= s3c64xx_init_uarts,
            .init		= s3c6400_init,
            .name		= name_s3c6400,
        }, {
            .idcode		= S3C6410_CPU_ID,
            .idmask		= S3C64XX_CPU_MASK,
            .map_io		= s3c6410_map_io,
            .init_clocks	= s3c6410_init_clocks,
            .init_uarts	= s3c64xx_init_uarts,
            .init		= s3c6410_init,
            .name		= name_s3c6410,
        },
    };

* /linux-3.10/arch/arm/mach-s3c64xx/common.c

  定义s3c64xx开发板通用的一些资源和函数，供具体的板级文件使用，例如./mach-mini6410.c

* /linux-3.10/arch/arm/mach-s3c64xx/mach-mini6410.c

  定义板级文件相关内容，包括主要的外设资源，以及开发板初始化等一些列操作，最后通过MACHINE_START和MACHINE_END宏将其定义到一个struct machine_desc结构中

  ::

    MACHINE_START(MINI6410, "MINI6410")
        /* Maintainer: Darius Augulis <augulis.darius@gmail.com> */
        .atag_offset	= 0x100,
        .init_irq	= s3c6410_init_irq,
        .map_io		= mini6410_map_io,
        .init_machine	= mini6410_machine_init,
        .init_late	= s3c64xx_init_late,
        .init_time	= samsung_timer_init,
        .restart	= s3c64xx_restart,
    MACHINE_END


  - platform设备

    在此文件中定义了一个platform_device的数组

    ::

      static struct platform_device *mini6410_devices[] __initdata = {
          &mini6410_device_eth,
          &s3c_device_hsmmc0,
          &s3c_device_hsmmc1,
          &s3c_device_ohci,
          &s3c_device_nand,
          &s3c_device_fb,
          &mini6410_lcd_powerdev,
          &s3c_device_adc,
          &s3c_device_ts,
      };

   随后，在mini6410_machine_init()中将这些platform设备加入

   ::

     static void __init mini6410_machine_init(void)
     {
         ...

         platform_add_devices(mini6410_devices, ARRAY_SIZE(mini6410_devices));
     }

  - Nand Flash

    Nand Flash分区信息

    ::

      static struct mtd_partition mini6410_nand_part[] = {
          [0] = {
              .name	= "uboot",
              .size	= SZ_1M,
              .offset	= 0,
          },
          [1] = {
              .name	= "kernel",
              .size	= SZ_2M,
              .offset	= SZ_1M,
          },
          [2] = {
              .name	= "rootfs",
              .size	= MTDPART_SIZ_FULL,
              .offset	= SZ_1M + SZ_2M,
          },
      };

其他
----

module_driver(__driver, __register, __unregister, ...)

应用层辅助工具
--------------

fbset
sysfsutils
mtd-utils
usbutils

设备驱动模型及子系统
====================

bus-device-driver 设备驱动模型
------------------------------

Platform 虚拟总线
-----------------

6410中的platform驱动包括：I2C、LCD、看门狗等

主要的数据结构

struct platform_device

  包括设备名、资源等信息

struct platform_driver

  包括各种操作，例如probe remove等

  ::

    int platform_device_add(struct platform_device *pdev)
    void platform_device_del(struct platform_device *pdev)
    int platform_device_register(struct platform_device *pdev)
    void platform_device_unregister(struct platform_device *pdev)

    

输入子系统
----------

视频子系统(framebuffer)
-----------------------

参考：Documentation/fb/framebuffer.txt

物理显示设备的工作原理如下：显示屏可以看作由一个一个像素组成，在显示的时候可以理解为向某个像素绘制某种颜色，整个屏幕的绘制顺序是从左到右，然后移动到下一行的行首，如此往复。绘制完整个屏幕之后，会跳回到屏幕的左上角。从上一行的行尾到下一行的行首所需时间被称为(horizontal retrace)，绘制完一屏后，从屏的右下角到左上角所需时间被称为(vertical retrace)。

屏幕的横纵分辨率分别被称为xres和yres。物理设备绘制的大小比实际的屏幕大，多出来的部分上下左右分别被称为upper margin, lower margin,left margin和right margin。另外，显示器并不知道什么时候开始一个新行，而是由一个行同步脉冲(horizontal sync或者简称为hsync)告诉它何时开始新行，hsync持续时间称为hsync len。同理，由列同步脉冲(vertical sync或者简称为vsync)告诉它何时从左上角开始绘制一个新屏(frame)，vsync持续时间称为vsync len。

.. image:: ./img/driver_framebuffer.png

..
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |upper_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------###############################################----------+-------+
     |          #                ↑                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |   left   #                |                            #  right   | hsync |
     |  margin  #                |       xres                 #  margin  |  len  |
     |<-------->#<---------------+--------------------------->#<-------->|<----->|
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |yres                        #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                ↓                            #          |       |
     +----------###############################################----------+-------+
     |          |                ↑                            |          |       |
     |          |                |lower_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |vsync_len                   |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+

从上图可以看出

::

  horizontal retrace = left margin  + right margin + hsync len
  vertical   retrace = upper margin + lower margin + vsync len

在编写驱动程序时，最主要的工作之一就是配置显示设备的物理参数，可以使用用户层命令fbset获得。

::

  mode "480x272-501595"
      # D: 76923.077 MHz, H: 145964.093 kHz, V: 501594.821 Hz
      geometry 480 272 480 272 16
      timings 13 40 5 9 8 2 2
      accel false
      rgba 5/11,6/5,5/0,0/0
  endmode


绘制每个像素的时间称为dotclock(单位是ps，即 picoseconds，1 s = 10^12 ps)。

在fbset命令的输出中D、H、V代表分别绘制一个像素、一行和一屏的频率。

geometry行分别表示可视水平分辨率(visible horizontal resolution，即xres)、可视垂直分辨率(visible vertical resolution，即yres)、虚拟水平分辨率(virtual horizontal resolution)、虚拟垂直分辨率(virtual vertical resolution)，以及颜色深度值，即每个像素需要几bit来表示。

timings行分别表示dotclock, left margin, right margin, upper margin, lower margin, hsync len 和 vsync len，单位是ps。

可以使用上面的知识，由geometry和timings的内容计算出D、H和V的值，验证fbset的输出，计算过程如下

::

  D = 1 / dotclock
    = 1 / (13 ps)
    = 76923.0769 MHz

  H = 1 / (dotclock * (xres + horizontal retrace))
    = 1 / (dotclock * (xres + left_margin + right_margin + hsync+len))
    = 1 / (dotclock * (480  + 40          + 5            + 2        ))
    = 1 / (13 ps    * 527 pixels)
    = 145964.093 KHz

  V = 1 / (dotclock * (xres + horizontal retrace) * (yres + vertical retrace))
    = 1 / (dotclock * (xres + left_margin  + right_margin + hsync+len)
                    * (yres + upper_margin + lower_margin + vsync+len))
    = 1 / (dotclock * (480  + 40           + 5            + 2)
                    * (272  + 9            + 8            + 2))
    = 1 / (13 ps * (527 * 291) pixel)
    = 501594.821 Hz

    

..
   Generic gpio library
   --------------------

   LED
   ---

   leds-gpio
   ~~~~~~~~~

   Generic input layer
   -------------------

   gpio_keys
   ~~~~~~~~~~~~~~~

   mtd子系统
   ---------

内核机制
========

并发控制( 信号量、自旋锁)
-------------------------

内核定时器
----------

休眠与唤醒
----------

中断
----

- include/linux/interrupt.h

  + 注册中断、释放中断

    ::

      request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
              const char *name, void *dev);

      void free_irq(unsigned int, void *);

  + 触发方式：上升沿、下降沿、高电平、低电平

    ::

      #define IRQF_TRIGGER_RISING	0x00000001
      #define IRQF_TRIGGER_FALLING	0x00000002
      #define IRQF_TRIGGER_HIGH	0x00000004
      #define IRQF_TRIGGER_LOW	0x00000008

异步通知
--------

驱动测试程序需要做的：

1. 将当前进程设置为设备文件的"属主"进程。通过使用fcntl的F_SETOWN参数设置，将进程号保存在filp->f_owner中。
2. 针对打开的驱动的设备文件，设置FASYNC标志。

驱动程序需要做的：

1. 在驱动测试程序设置F_SETOWN时，对filp->f_owner赋值。这一步会自动完成，驱动中不需要添加额外的代码。
2. 实现struct file_operations中的fasync调用，在fasync函数中通过内核提供的fasync_helper()来响应测试程序设置的FASYNC标志。
3. 数据达到时，使用kill_fasync()，向注册的"属主"进程发送SIGIO信号。
4. 在struct file_operations的release函数中，明确使用.fasync(-1, filp, 0)从异步通知列表中移除filp。

硬件设备驱动程序开发
====================

串口
----

主要的数据结构
~~~~~~~~~~~~~~

* uart driver

  ::

    struct uart_driver
    int uart_register_driver(struct uart_driver *uart);
    void uart_unregister_driver(struct uart_driver *uart);

* uart port

  ::

    struct uart_port
    int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
    int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);

* uart ops

  ::

    struct uart_ops

* console

  ::

    struct console

主要的操作
~~~~~~~~~~

定义在struct uart_ops中

::

  /*
   * This structure describes all the operations that can be done on the
   * physical hardware.  See Documentation/serial/driver for details.
   */
  struct uart_ops {
  	unsigned int	(*tx_empty)(struct uart_port *);
  	void		(*set_mctrl)(struct uart_port *, unsigned int mctrl);
  	unsigned int	(*get_mctrl)(struct uart_port *);
  	void		(*stop_tx)(struct uart_port *);
  	void		(*start_tx)(struct uart_port *);
  	void		(*throttle)(struct uart_port *);
  	void		(*unthrottle)(struct uart_port *);
  	void		(*send_xchar)(struct uart_port *, char ch);
  	void		(*stop_rx)(struct uart_port *);
  	void		(*enable_ms)(struct uart_port *);
  	void		(*break_ctl)(struct uart_port *, int ctl);
  	int		(*startup)(struct uart_port *);
  	void		(*shutdown)(struct uart_port *);
  	void		(*flush_buffer)(struct uart_port *);
  	void		(*set_termios)(struct uart_port *, struct ktermios *new,
  				       struct ktermios *old);
  	void		(*set_ldisc)(struct uart_port *, int new);
  	void		(*pm)(struct uart_port *, unsigned int state,
  			      unsigned int oldstate);
  	int		(*set_wake)(struct uart_port *, unsigned int state);

  	/*
  	 * Return a string describing the type of the port
  	 */
  	const char	*(*type)(struct uart_port *);

  	/*
  	 * Release IO and memory resources used by the port.
  	 * This includes iounmap if necessary.
  	 */
  	void		(*release_port)(struct uart_port *);

  	/*
  	 * Request IO and memory resources used by the port.
  	 * This includes iomapping the port if necessary.
  	 */
  	int		(*request_port)(struct uart_port *);
  	void		(*config_port)(struct uart_port *, int);
  	int		(*verify_port)(struct uart_port *, struct serial_struct *);
  	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
  #ifdef CONFIG_CONSOLE_POLL
  	int		(*poll_init)(struct uart_port *);
  	void		(*poll_put_char)(struct uart_port *, unsigned char);
  	int		(*poll_get_char)(struct uart_port *);
  #endif
  };

* 数据发送

  数据保存在struct circ_buf中

  - pull模式
  - 利用中断的数据发送

* 数据接收

* modem控制线

* termios

* console

Nand Flash
----------

struct mtd_part

  表示分区信息

add_mtd_partitions()
del_mtd_partitions()

add_mtd_device()
del_mtd_device()

USB
---

struct usb_string_descriptor
struct usb_endpoint_descriptor
struct usb_interface_descriptor
struct usb_config_descriptor
struct usb_device_descriptor

struct usb_hcd
struct hc_driver

Network
-------

LCD硬件相关
~~~~~~~~~~~

- 信号

  VSYNC         垂直方向同步信号(vertical sync)
  HSYNC         水平方向同步信号(horizontal sync)
  VDEN          (video data enable)
  VCLK          时钟信号(video clock)
  LED+、LED-    背光信号
  VD0-VD23      RGB信号(video data)

- 配置

  bpp(bit per pixel)
