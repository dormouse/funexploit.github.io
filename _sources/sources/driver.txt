=================
linux驱动开发笔记
=================

.. contents::


为了学习linux驱动和内核的开发，买了块友善tiny6410的板子，开始了嵌入式系统的学习。本文是我在学习过程中的笔记，会随着自己的学习持续更新，文章如有错误，敬请指正。

另外寻求有兴趣的朋友一起学习折腾、实时交流心得体会和问题。 `funexploit # aliyun.com <funexploit # aliyun.com>`_

============
开发环境搭建
============

主机为 ubuntu ，开发板为 tiny6410 ，在驱动开发过程中通过串口和网线连接主机和开发板。

在主机上开启 tftp 服务和 NFS 服务，然后设置好 u-boot，通过 tftp 将内核加载到开发板 sdram 中，然后启动内核，再通过 NFS 挂载主机上的根文件系统。这样可以加速驱动的开发。

串口通信工具kermit配置
======================

安装

::

   aptitude install ckermit

创建kermit配置文件/root/.kermrc

::

  set line /dev/ttyUSB0
  set speed 115200
  set carrier-watch off
  set handshake none
  set flow-control none
  robust
  set file type bin
  set file name lit
  set rec pack 1000
  set send pack 1000
  set window 5
  c

tftp服务配置
============

安装

::

   aptitude install tftpd-hpa

创建 tftpd 根目录

::

   mkdir /tftproot

修改配置文件 `/etc/inetd.conf` 添加以下内容

::

   tftp dgram udp wait root /usr/sbin/tcpd /usr/sbin/in.tftpd -s /tftproot

由于 tftp 服务是由 inetd 服务管理的，我们需要将 inetd 服务设置为随系统启动

::

   update-rc.d openbsd-inetd defaults

重新启动系统，这一步必不可少。然后将 zImage 复制到 /tftproot 下即可。

NFS服务配置
===========

安装

::

   aptitude install nfs-server

修改配置文件 `/etc/exports` 添加以下内容

::

   /home/forfun/pro/7.embeddedsystem/rootfs/ *(async,rw,no_root_squash,anonuid=0,anongid=0,no_subtree_check)

添加服务随系统运行

::

   update-rc.d nfs-kernel-server defaults

u-boot设置
==========

设置IP地址相关的环境变量，将 u-boot 的 ip 设置为 192.168.2.101，ubuntu 主机为 192.168.2.100

::

   setenv ipaddr 192.168.2.101
   setenv serverip 192.168.2.100

设置环境变量通过tftp加载内核并运行

::

   setenv bootcmd 'tftpboot 0xc0008000 zImage; bootm 0xc0008000'

设置环境变量通过NFS加载主机上的根文件系统

::

   setenv bootargs 'console=ttySAC0 root=/dev/nfs nfsroot=192.168.2.100:/home/forfun/pro/7.embeddedsystem/rootfs/rootfs_qtopia_qt4,proto=tcp,nolock ip=192.168.2.102:192.168.2.100:192.168.2.100:255.255.255.0:mini6410:eth0:off`

保存刚才设置的所有环境变量并重启

::

   saveenv
   reset

安装内核文档
============

在内核根目录下用root权限执行以下命令

::

   make installmandocs

会将内核的 man 手册安装到 /usr/local/man/man9/


遇到的疑难杂症
==============

- 使用下载的交叉编译工具，运行时提示"No such file or directory"

  由于使用的是64位的系统，而交叉编译工具是32位的，需要安装几个库文件

  ::

     aptitude install lib32ncurses5 lib32z1 lib32bz2-1.0

- 通过NFS挂载根系统时，提示"can't open /r/dev/console: no such file"

  禁用内核中下面的选项即可

  ::

    CONFIG_BLK_DEV_INITRD:

    The initial RAM filesystem is a ramfs which is loaded by the
    boot loader (loadlin or lilo) and that is mounted as root
    before the normal boot procedure. It is typically used to
    load modules needed to mount the "real" root file system,
    etc. See <file:Documentation/initrd.txt> for details.

    If RAM disk support (BLK_DEV_RAM) is also included, this
    also enables initial RAM disk (initrd) support and adds
    15 Kbytes (more on some other architectures) to the kernel size.

    If unsure say Y.

    Symbol: BLK_DEV_INITRD [=n]
    Type  : boolean
    Prompt: Initial RAM filesystem and RAM disk (initramfs/initrd) support
      Defined at init/Kconfig:865
      Depends on: BROKEN [=n] || !FRV
      Location:
        -> General setup



================
驱动模型及子系统
================

Linux设备驱动模型
=================

linux 内核中的驱动模型主要由总线(bus)、设备(device)和驱动(driver)组成。

总线(bus)
---------

任何一个设备或者任何一个驱动，都必须绑定在某一类总线上。linux通过总线将设备与驱动关联起来，当在总线上注册一个设备的时候，会自动搜索已经在此总线上注册的驱动，然后进行匹配，同样，当在总线上注册一个驱动的时候，也会去匹配总线上已经注册的设备。

注意：一个设备只能有一个驱动程序与之关联，而一个驱动程序则可能匹配多个设备。

在内核中，用 `struct bus_type` 来表示总线类型。

::

   struct bus_type {
           const char                   *name;
           struct bus_attribute         *bus_attrs;
           struct device_attribute      *dev_attrs;
           struct driver_attribute      *drv_attrs;

           int (*match)(struct device *dev, struct device_driver *drv);
           int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
           int (*probe)(struct device *dev);
           int (*remove)(struct device *dev);
           void (*shutdown)(struct device *dev);

           int (*suspend)(struct device *dev, pm_message_t state);
           int (*resume)(struct device *dev);

           const struct dev_pm_ops *pm;

           struct subsys_private *p;
   };

总线使用其中的 `int (*match)(struct device *dev, struct device_driver *drv)` 对设备和驱动进行匹配，如果能够匹配，则返回非零值。

总线类型使用 `bus_register` 和 `bus_unregister` 进行注册和注销。

::

   extern int __must_check bus_register(struct bus_type *bus);
   extern void bus_unregister(struct bus_type *bus);

设备(device)
------------

内核中用 `struct device` 结构来表示一个物理设备。

::

  struct device {
          struct device           *parent;

          struct device_private   *p;

          struct kobject kobj;
          const char              *init_name; /* initial name of the device */
          struct device_type      *type;

          struct bus_type *bus;           /* type of bus device is on */
          struct device_driver *driver;   /* which driver has allocated this
                                             device */
          void            *platform_data; /* Platform specific data, device
                                             core doesn't touch it */
          struct dev_pm_info      power;

  #ifdef CONFIG_NUMA
          int             numa_node;      /* NUMA node this device is close to */
  #endif
          u64             *dma_mask;      /* dma mask (if dma'able device) */
          u64             coherent_dma_mask;/* Like dma_mask, but for
                                               alloc_coherent mappings as
                                               not all hardware supports
                                               64 bit addresses for consistent
                                               allocations such descriptors. */

          struct device_dma_parameters *dma_parms;

          struct list_head        dma_pools;      /* dma pools (if dma'ble) */

          struct dma_coherent_mem *dma_mem; /* internal for coherent mem
                                               override */
          /* arch specific additions */
          struct dev_archdata     archdata;
  #ifdef CONFIG_OF
          struct device_node      *of_node;
  #endif

          dev_t                   devt;   /* dev_t, creates the sysfs "dev" */

          spinlock_t              devres_lock;
          struct list_head        devres_head;

          struct klist_node       knode_class;
          struct class            *class;
          const struct attribute_group **groups;  /* optional groups */

          void    (*release)(struct device *dev);
  };

其中的 `const char init_name` 唯一标识设备的名称， `sturct bus_type *bus` 则标识该设备连接在哪种类型的总线上。 `struct device_driver *driver` 表示与此设备相关联的驱动。


设备使用 `device_register` 和 `device_unregister` 进行注册和注销。

::

   extern int __must_check device_register(struct device *dev);
   extern void device_unregister(struct device *dev);

注意：总线本身也是一个 `设备` ，因此也必须注册为一个设备实例。而设备和驱动是与 `总线类型(struct bus_type)` 相关联，而不是 `总线设备(struct device)` 。

驱动(driver)
------------

内核中使用 `struct device_driver` 结构来表示驱动。

::

  struct device_driver {
          const char              *name;
          struct bus_type         *bus;

          struct module           *owner;
          const char              *mod_name;      /* used for built-in modules */

          bool suppress_bind_attrs;       /* disables bind/unbind via sysfs */

  #if defined(CONFIG_OF)
          const struct of_device_id       *of_match_table;
  #endif

          int (*probe) (struct device *dev);
          int (*remove) (struct device *dev);
          void (*shutdown) (struct device *dev);
          int (*suspend) (struct device *dev, pm_message_t state);
          int (*resume) (struct device *dev);
          const struct attribute_group **groups;

          const struct dev_pm_ops *pm;

          struct driver_private *p;
  };

其中的 `const char *name` 是唯一标识此驱动的名称， `struct bus_type *bus` 则标识该驱动连接在哪种类型的总线上。


设备使用 `driver_register` 和 `driver_unregister` 进行注册和注销。

::

   extern int __must_check driver_register(struct device_driver *drv);
   extern void driver_unregister(struct device_driver *drv);

视频子系统(framebuffer)
=======================

参考：Documentation/fb/framebuffer.txt

物理显示设备的工作原理如下：显示屏可以看作由一个一个像素组成，在显示的时候可以理解为向某个像素绘制某种颜色，整个屏幕的绘制顺序是从左到右，然后移动到下一行的行首，如此往复。绘制完整个屏幕之后，会跳回到屏幕的左上角。从上一行的行尾到下一行的行首所需时间被称为(horizontal retrace)，绘制完一屏后，从屏的右下角到左上角所需时间被称为(vertical retrace)。

屏幕的横纵分辨率分别被称为xres和yres。物理设备绘制的大小比实际的屏幕大，多出来的部分上下左右分别被称为upper margin, lower margin,left margin和right margin。另外，显示器并不知道什么时候开始一个新行，而是由一个行同步脉冲(horizontal sync或者简称为hsync)告诉它何时开始新行，hsync持续时间称为hsync len。同理，由列同步脉冲(vertical sync或者简称为vsync)告诉它何时从左上角开始绘制一个新屏(frame)，vsync持续时间称为vsync len。

.. image:: ./img/driver_framebuffer.png

..
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |upper_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------###############################################----------+-------+
     |          #                ↑                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |   left   #                |                            #  right   | hsync |
     |  margin  #                |       xres                 #  margin  |  len  |
     |<-------->#<---------------+--------------------------->#<-------->|<----->|
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |yres                        #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                |                            #          |       |
     |          #                ↓                            #          |       |
     +----------###############################################----------+-------+
     |          |                ↑                            |          |       |
     |          |                |lower_margin                |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+
     |          |                ↑                            |          |       |
     |          |                |vsync_len                   |          |       |
     |          |                ↓                            |          |       |
     +----------+---------------------------------------------+----------+-------+

从上图可以看出

::

  horizontal retrace = left margin  + right margin + hsync len
  vertical   retrace = upper margin + lower margin + vsync len

在编写驱动程序时，最主要的工作之一就是配置显示设备的物理参数，可以使用用户层命令fbset获得。

::

  mode "480x272-501595"
      # D: 76923.077 MHz, H: 145964.093 kHz, V: 501594.821 Hz
      geometry 480 272 480 272 16
      timings 13 40 5 9 8 2 2
      accel false
      rgba 5/11,6/5,5/0,0/0
  endmode


绘制每个像素的时间称为dotclock(单位是ps，即 picoseconds，1 s = 10^12 ps)。

在fbset命令的输出中D、H、V代表分别绘制一个像素、一行和一屏的频率。

geometry行分别表示可视水平分辨率(visible horizontal resolution，即xres)、可视垂直分辨率(visible vertical resolution，即yres)、虚拟水平分辨率(virtual horizontal resolution)、虚拟垂直分辨率(virtual vertical resolution)，以及颜色深度值，即每个像素需要几bit来表示。

timings行分别表示dotclock, left margin, right margin, upper margin, lower margin, hsync len 和 vsync len，单位是ps。

可以使用上面的知识，由geometry和timings的内容计算出D、H和V的值，验证fbset的输出，计算过程如下

::

  D = 1 / dotclock
    = 1 / (13 ps)
    = 76923.0769 MHz

  H = 1 / (dotclock * (xres + horizontal retrace))
    = 1 / (dotclock * (xres + left_margin + right_margin + hsync+len))
    = 1 / (dotclock * (480  + 40          + 5            + 2        ))
    = 1 / (13 ps    * 527 pixels)
    = 145964.093 KHz

  V = 1 / (dotclock * (xres + horizontal retrace) * (yres + vertical retrace))
    = 1 / (dotclock * (xres + left_margin  + right_margin + hsync+len)
                    * (yres + upper_margin + lower_margin + vsync+len))
    = 1 / (dotclock * (480  + 40           + 5            + 2)
                    * (272  + 9            + 8            + 2))
    = 1 / (13 ps * (527 * 291) pixel)
    = 501594.821 Hz

MTD子系统
=========

概述
----

(此处只讨论nand flash类型的驱动)

mtd子系统为访问闪存设备提供抽象，mtd子系统在内核中从上到下可以分为以下几层：

- mtd字符设备接口、mtd块设备接口
- mtd核心层
- flash核心层
- falsh硬件驱动层

1. mtd字符设备接口、mtd块设备接口

   mtd字符设备接口将mtd设备映射为字符设备，对应的设备节点为 /dev/mtdN，可以使用字符设备的接口对其进行操作。源文件文件为

   ::

     drivers/mtd/mtdchar.c

   mtd块设备接口将mtd设备映射为块设备，对应的设备节点为 /dev/mtdblockN，可以使用块设备的接口对其进行操作。对应的文件为

   ::

     drivers/mtd/mtdblock.c

2. mtd核心层

   mtd核心层不必了解具体的flash类型(nor、nand或者onenand等等)，可以向上提供统一的接口。

   对应的文件为

   ::

     drivers/mtd/mtdcore.c
     drivers/mtd/mtdsuper.c
     drivers/mtd/mtdpart.c
     drivers/mtd/ofpart.c

3. flash核心层

   这是在mtd核心层下面的又一层抽象，针对具体的不同类型的flash硬件(nor、nand或者onenand等等)，实现flash类型相关的一些通用的功能。

   nand flash核心层对应的文件为

   ::

     drivers/mtd/nand/nand_base.c
     drivers/mtd/nand/nand_bbt.c
     drivers/mtd/nand/nand_ecc.c
     drivers/mtd/nand/nand_ids.c
     drivers/mtd/nand/sm_common.c

4. falsh硬件驱动层

   针对具体的不同型号的flash硬件实现的驱动程序，我们要实现的就是这一层的驱动。nand flash硬件驱动层源代码位于 drivers/mtd/nand/ 目录下。

主要的数据结构和操作
--------------------

::

   struct mtd_info         最主要的 mtd 结构体， 包含 mtd 设备的通用信息
   struct mtd_part         分区信息(mtd 内部使用)    ?
   struct mtd_partition    分区信息(驱动开发者使用)  ?
   struct nand_chip        具体的 nand flash 硬件相关的信息及操作函数

   struct platform_nand_data {
   struct platform_nand_chip chip;
   struct platform_nand_ctrl ctrl;
   };
   struct platform_nand_chip
   struct platform_nand_ctrl

nand flash驱动的主要工作
------------------------

参考内核中通用的 SoC Nand Flash 驱动程序 drivers/mtd/nand/plat_nand.c 。

- platform driver 部分需要完成的工作

  1. 使用 request_mem_region() 预留内存地址空间，并使用 ioremap() 映射内存
  #. 定义并分配 struct mtd_info 和 struct nand_chip，并将 mtd_info->priv 指向 nand_chip
  #. 使用 platform device定义的各种硬件相关的操作函数，给 nand_chip 赋值
  #. 用 nand_scan(mtd_info, nand_chip->nr_chips) 探测 nand flash
  #. 用 parse_mtd_partitions() 解析分区信息，然后用 add_mtd_partitions() 添加分区
  #. 最后用 add_mtd_device(mtd_info) 添加 mtd 设备

- platform device 部分需要完成的工作

  1. 定义 struct mtd_partition 结构体数组，其中包含 nand flash 的分区信息
  #. 定义 struct resource 结构体数组，其中包含将 nand flash 映射成的对应的内存地址
  #. 定义硬件相关的各种操作函数(需要在 platform driver 部分赋值给 nand_chip)

遇到的问题
----------

使用友善之臂提供的内核中，nand flash 驱动并不是开源的，与内核配置文件 drivers/mtd/nand/Kconfig 中的 MTD_NAND_S3C 选项没有关系，即与 drivers/mtd/nand/s3c_nand.c 文件无关。

它是通过在 drivers/mtd/nand/Makefile 末尾添加了几行来实现

::

  S3C_NAND_MLC_SRC = $(shell ls drivers/mtd/nand/s3c_nand_mlc.c 2>/dev/null)
  ifeq ($(S3C_NAND_MLC_SRC),)
  obj-$(CONFIG_MTD_NAND_S3C)			+= s3c_nand_mlc.fo
  else
  obj-$(CONFIG_MTD_NAND_S3C)			+= s3c_nand_mlc.o
  endif

想禁用它的驱动程序，将其注释掉即可。注意在 Kconfig 文件中没有相应的选项，与 BSP 中关于 nand flash 的内容也不相关。

参考

- Linux内核中NAND Flash坏块管理
  http://blog.csdn.net/linux_xiaomugua/article/details/7529348
- linux内核中对nand的坏块管理
  http://blog.csdn.net/haomcu/article/details/8181622
- bbt坏块管理
  http://blog.chinaunix.net/uid-22028566-id-1803151.html
- 硬件ECC
  http://www.360doc.com/content/14/0918/14/18578054_410432848.shtml
- nand flash坏块管理OOB,BBT,ECC
  http://www.cnblogs.com/elect-fans/archive/2012/05/14/2500643.html

========
内核机制
========

异步通知
========

驱动测试程序需要做的：

1. 将当前进程设置为设备文件的"属主"进程。通过使用fcntl的F_SETOWN参数设置，将进程号保存在filp->f_owner中。
2. 针对打开的驱动的设备文件，设置FASYNC标志。

驱动程序需要做的：

1. 在驱动测试程序设置F_SETOWN时，对filp->f_owner赋值。这一步会自动完成，驱动中不需要添加额外的代码。
2. 实现struct file_operations中的fasync调用，在fasync函数中通过内核提供的fasync_helper()来响应测试程序设置的FASYNC标志。
3. 数据达到时，使用kill_fasync()，向注册的"属主"进程发送SIGIO信号。
4. 在struct file_operations的release函数中，明确使用.fasync(-1, filp, 0)从异步通知列表中移除filp。

========
驱动实例
========

LED
===

.. image:: ./img/board_led.png

上图为tiny6410核心板原理图关于LED的部分，可以看出led1-4由GPK4-7控制，并且这些引脚是复用引脚，点亮led需要对应的引脚为为低电平。

.. image:: ./img/datasheet_led_register.png

这是tiny6410的datasheet中关于GPK寄存器的截图。我们的目的是让led根据设置的引脚来相应地发生变化，所以它们应该为输出模式，从图可以看出GPK4-7分别由GPKCON0的[19:16]、[23:20]、[27:24]和[31:28]控制，需要将其分别设置为b0001。

GPK4-7的值可以通过向GPKDAT[n]对应的位写入即可。

硬盘NandFlash
=============

概述
----

.. image:: ./img/board_nand.png

这是 nand flash 的电路图。注意电路图中 nand flash 型号为 K9F2G08 ，但是开发板上实际使用的型号为 K9GAG08U0E ，原理是一样的。

- 引脚说明

  ::

    I/O0 ~ I/O7   8根I/O线路，用来发送接受地址/数据/命令
    WE            write enable
    RE            read enable
    CLE           command latch enable
    ALE           address latch enable
    CE            chip enable 片选信号
    R/#B          ready/busy状态指示

  当 CLE 为高电平时，8条I/O线路上传输的是命令信号，当 ALE 为高电平时，传输的是地址信号，当 CLE 和 ALE 都为低电平时，传输的是数据信号。

  当 WE 为高电平时，表示向 nand flash 写入，当 RE 为高电平时，表示从 nand flash 读出。

  当 R/#B 为低电平时表示 busy ，为高电平时表示 ready 。

  SoC包含了一个 nand flash 控制器，当 CPU 需要对 nand flash 进行操作时，直接设置寄存器或者读取寄存器的值即可， nand flash 控制器负责直接和 nand flash 进行交互。

  访问 nand flash 不能像访问内存一样方便，例如读取 nand flash 中某个地址的数据，需要先发出读数据命令，然后发出数据的地址，最后接受数据。具体操作时，由于有 nand flash 控制器的存在，发出数据时，只需要将数据写入某个寄存器即可，读取数据时，也只需要读取特定的寄存器。

背景知识
--------

.. image:: ./img/nand_organization.png

整个nand flash由2076个块(block)组成，每个块(block)由128个页(page)组成，而每个页的大小为8K，读写的最小单位就是page。每一页附带有436字节的错误校验码，这部分属于另外的空间，不属于平时访问的nand flash地址空间，读取错误校验码需要使用特殊的读命令。另外，在访问nand flash时，块和页的地址合起来称为行(row)地址，而页内偏移地址又称为列(column)地址。

初始化
------

* 时序设置

  datasheet上需要设置三个时序，如下图所示:

  .. image:: ./img/datasheet_nand_time.png

  上面的时序图中的nWE和nRE都应该是低电平有效，图中错误。

  .. image:: ./img/nand_timing.png


  上面这是 nand flash手册中的时序图。


  .. image:: ./img/datasheet_nand_time_register.png

  这是时序对应寄存器的各个位。

  设置时序时涉及到nand flash的时钟，我们可以知道来自于HCLK，值为266MHz，换算后大约为3.76ns。

  - TACLS

    这是从CLE/ALE变成有效之后，间隔多长时间WE变成有效，对应于nand flash手册中时序图(tCLS-tWP)和(tALS-tWP)这两个值中的较大的那个。tCLS、tALS和tWP都最小为15ns，所以这个值设为0或者1都可以。

  - TWRPH0

    这是WE和RE所持续的时间，对应于nand flash手册中时序图tWP和tRP这两个值中的较大的那个，这两个值都最小为15ns。而换算公式为:

    ::

      持续时间=HCLK*(TWRPH0+1)

    其中的持续时间最小为15ns，HCLK为3.76ns，所以TWRPH0设置为3或4或者更大的值都可以。由于对应的寄存器只有三位，所以最大为7。

  - TWRPH1

    这是WE和RE变成无效之后，CLE/ALE还持续多长时间，对应于nand flash手册中时序图tCLH和tALH这两个值中的较大的那个，这两个值都最小为5ns。而换算公式为:

    ::

      持续时间=HCLK*(TWRPH1+1)

    其中的持续时间最小为5ns，HCLK为3.76ns，所以TWRPH1设置为1即可。

  所以最终的时序设置如下:

  ::

    NFCONF = setval(NFCONF, 6, 4, 1);	/* TWRPH1 */
    NFCONF = setval(NFCONF, 10, 8, 3);  /* TWRPH0 */
    NFCONF = setval(NFCONF, 14, 12, 0); /* TACLS */
