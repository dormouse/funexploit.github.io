====================
内核同步方法及其比较
====================

.. contents::

原子操作
========

包括32位、64位原子整数操作和原子位操作

自旋锁
======

内核中最常见的锁机制就是自旋锁。

自旋锁的目的是在短期内进行轻量级加锁，因为自旋锁不应该被长时间持有。

Linux内核中实现的自旋锁不能递归使用，尝试获取自己已经持有的自旋锁，会导致被自己锁死。

自旋锁可以在不能休眠的代码中使用，比如中断处理程序。而且拥有自旋锁的代码必须是原子的，绝对不能休眠，否则其它线程试图获得同一个锁，可能会导致死锁。

自旋锁的操作

::

   void spin_lock_init(spinlock_t *lock)

   void spin_lock(spinlock_t *lock)
   void spin_unlock(spinlock_t *lock)


   void spin_lock_irq(spinlock_t *lock)
   void spin_unlock_irq(spinlock_t *lock)

   void spin_lock_irqsave(spinlock_t *lock)
   void spin_unlock_irqrestore(spinlock_t *lock)

   int spin_trylock(spinlock_t *lock)
   int spin_is_locked(spinlock_t *lock)

信号量
======

信号量是一种休眠锁，一个任务在获取一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其休眠。当信号量被释放时，原先休眠的任务会被唤醒。

只能在进程上下文中获取信号量，不能在中断上下文中获取信号量，因为中断上下文中进程不能被调度成休眠状态。

自旋锁和信号量不能同时占有，因为在等待信号量的时候进城可能被调度成休眠状态，而在持有自旋锁时是不允许休眠的。

信号量不同于自旋锁，它不会禁止内核抢占，所以持有信号量的代码可以被抢占。

如果代码可以休眠，则只能使用信号量，不能自旋锁。
如果锁可能会被占用较长时间，使用信号量，否则使用自旋锁。

信号量一般情况下应该使用可中断的版本。

信号量的操作

::

   void sema_init(struct semaphore *sem, int val)
   extern void down(struct semaphore *sem);
   extern int __must_check down_interruptible(struct semaphore *sem);
   extern int __must_check down_killable(struct semaphore *sem);
   extern int __must_check down_trylock(struct semaphore *sem);
   extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
   extern void up(struct semaphore *sem);

互斥体
======

互斥体是指任何可以休眠的强制互斥锁。互斥体是一种互斥信号。

互斥体使用上相对于信号量更加严格。最重要的一条是：上锁者必须负责解锁（），当持有互斥体锁时进程不能退出。另外，同信号量一样，互斥体不能在中断内部或者中断的下半部中使用。

互斥体的操作

::

   struct mutex
   void mutex_init(struct mutex *)
   void mutex_lock(struct mutex *)
   void mutex_unlock(struct mutex *)
   int mutex_trylock(struct mutex *)
   int mutex_is_locked(struct mutex *)
