==============
嵌入式系统笔记
==============

.. contents::


为了学习linux驱动和内核的开发，买了块友善tiny6410的板子，开始了嵌入式系统的学习。本文是我在学习过程中的笔记，会随着自己的学习持续更新，文章如有错误，敬请指正。

另外寻求有兴趣的朋友一起学习折腾、实时交流心得体会和问题。 `funexploit # gmail.com <funexploit # gmail.com>`_

使用的主机配置如下

::

  root@mygentoo 7.Embeddedsystem # uname -a
  Linux mygentoo 3.9.3-gentoo #4 SMP Thu May 30 07:32:10 CST 2013 i686 Intel(R) Core(TM)2 Duo CPU T6500 @ 2.10GHz GenuineIntel GNU/Linux

概述
====

tiny6410开发板包括核心板和底板，核心板上包括了三星的S3C6410微处理器和2块Mobile DDR RAM(即内存)，以及一块Nand Flash(相当于PC机上的硬盘)。其中的S3C6410微处理器内部内部包含了ARM公司的CPU(即arm1176)和其它一些控制器，具体可查看三星的手册，CPU和这些控制器组合起来又称SOC(线上系统)，作用相当于PC机上的CPU和主板的组合。

在S3C6410内部包含了一个4K的SRAM，系统上电启动后会自动将Nand Flash前4K的内容复制到这个内部的SRAM中，接着CPU就会从这个4K的SRAM的起始地址开始执行，地址为0x0000_0000(这整个过程是和CPU相关的，是硬件实现的)，而外部的内存(即那2个Mobile DDR RAM)的起始地址为0x3000_0000，假如我们有2个128M的内存，那么结束地址定义为0x3000_0000+2*(128*1024*1024)=0x4000_0000。

这4K的SRAM的代码的主要功能包括：初始化系统，初始化外部硬件(包括RAM和Nand Flash等)，将Nand Flash上更多的内容复制到内存中，然后跳转过去开始执行。

嵌入式开发环境设置
==================

交叉编译环境设置
----------------

参考： Gentoo Embedded Handbook

安装corssdev

  ::

     emerge crossdev

安装交叉编译环境，包括gdb

  ::

     crossdev --ex-gdb --target arm-unknown-linux-gnueabi

调试工具设置
------------

* 串口：linux下USB转串口的驱动支持

  将串口转USB接口插到主机上，然后执行 lsusb 命令，会出现如下输出

  ::

    Bus 004 Device 002: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port

  说明已经被识别，但是随后却找不到 /dev/ttyUSB0 这个设备文件，说明可能是驱动程序没有安装，需要重新编译内核。开启内核中的相关选项，如下所示

  ::

    Symbol: USB_SERIAL_PL2303 [=m]
    Type  : tristate
    Prompt: USB Prolific 2303 Single Port Serial Driver
      Defined at drivers/usb/serial/Kconfig:480
      Depends on: USB_SUPPORT [=y] && USB_SERIAL [=y]
      Location:
        -> Device Drivers
          -> USB support (USB_SUPPORT [=y])
            -> USB Serial Converter support (USB_SERIAL [=y])

* JTAG调试程序：openocd

  安装

  ::

     emerge openocd

  安装之前要在/etc/portage/package.use/package.use中设置openocd的USE标
  志：segger

  ::

     dev-embedded/openocd segger

  配置文件

  将/usr/share/openocd/scripts/board/mini6410.cfg复制为/root/openocd.cfg，根据自己的需要修改里面的参数。

* 超级终端：minicom

  安装

  ::

     emerge minicom

关于调试工具的疑难问题
----------------------

1. openocd出现以下错误

   ::

     'arm11 target' JTAG error SCREG OUT 0x00
     in procedure 'resume'
     'arm11 target' JTAG error SCREG OUT 0x00
     Polling target s3c6410.cpu failed, GDB will be halted. Polling again in 100ms

   这种错误出现在配置了时钟之后执行resume时，由于配置文件里的adapter_khz参数设置问题，默认为1000，修改为与CPU时钟相同(533000khz)，调试时会出现如下提示

   ::

     Polling target s3c6410.cpu succeeded again

   可以正常进行调试，就当权宜之计吧。

   有时上面的步骤不起作用时，可以尝试将u-boot写到nand flash里然后重启，就正常了，不明白什么原因。

编写裸机代码时需要做的准备工作
==============================

ARM汇编
-------

其它
----

..
   3、使用 u-boot 中的 printf() 函数来帮助调试

   tftp file.txt 30000000 会出错
   tftp file.txt 60000000 则正确

   找出printf()函数在 u-boot.bin 中的地址，需要自己编译 u-boot，先在tiny6410自带的光盘A中的u-boot代码解压缩，然后在顶层目录执行以下命令来编译

   ::

     make mini6410_nand_config-ram256
     make all

   tiny6410包含了2个128的Mobile DDR SDRAM，所以上面对应的是256M的ram，另外可能需要修改顶层的 Makefile 文件后上面的命令才能正确执行，例如我本地交叉编译工具是arm-unknown-linux-gnueabi-gcc，在Makefile中有个变量是指定交叉编译工具的前缀的，默认是

   ::

     CROSS_COMPILE = arm-linux-

   根据需要将 Makefile 中上面的行改成下面的(有2处)

   ::

      CROSS_COMPILE = arm-unknown-linux-gnueabi-

   修改完 Makefile，编译完 u-boot，在顶层目录下会生成 u-boot.bin，我们需要
   把这个文件烧写到 nand flash 中，还有一个文件 System.map，printf()函数的
   地址就在里面

   ::

      grep printf System.map



学习计划
========

* 第一阶段:裸机调试 编写汇编或者c代码来直接操纵硬件和接口

  - 预备：ARM汇编语言
  - LED、按键、蜂鸣器
  - 时钟
  - 串口(UART)
  - 内存控制器(DDR SDRAM)
  - Nand Flash
  - 中断和异常
  - MMU

  - bootloader开发

  - I2C总线接口
  - LCD控制器

* 第二阶段:系统移植

  - bootloader移植
  - 移植linux内核
  - 构建linux系统

* 第三阶段:驱动开发

  -  一个基于内存的字符设备驱动
  -  一个基于内存的块设备驱动
  -  一个基于内存的网卡驱动
  -  一个虚拟总线(理解Linux驱动模型)

  - 按键控制的LED驱动、看门狗、蜂鸣器
  - UART
  - 触摸屏、LCD
  - 声卡驱动
  - I2C-EEPROM
  - USB
  - Nand Flash驱动
  - 以太网卡

  -  WiFi驱动

参考资料
========

* 嵌入式硬件设计(卡特索利斯)

  一本全面介绍基本硬件知识的书，没有复杂的原理，没有繁琐的公式，讲述非常浅显易懂，对于初涉嵌入式领域的软件开发人员绝对是一本普及硬件知识的好书。

* ARM体系结构与编程(杜春雷)

  描述ARM处理器的内部原理以及ARM汇编语言的一本书，还包括了ARM的存储管理、异常和中断等等，书中的有些部分需要仔细研读，而有些部分可以在需要时参考。

* 嵌入式Linux应用开发完全手册(韦东山)

  这是一本以实践操作驱动的书，最出彩的部分莫过于其中的第二部分，也就是裸机开发，跳过操作系统这个中间层，直接去操纵硬件，把这部分踏踏实实掌握了，到了linux下做驱动开发的时候才能游刃有余。这本书还配有详细的视频教程，非常赞，一起学习会事半功倍。

* Linux设备驱动开发详解（宋宝华）

  也是一本实践驱动的书，详细讲解了各种类型的设备驱动程序的详细开发过程，可以和LDD搭配起来一起看，以这本书为实践主线，以LDD为参考。

* Linux设备驱动程序(俗称LDD)

  学习linux驱动和内核的一本必备经典图书，从内核的角度对驱动程序的开发进行了详尽的描述，偏重原理性的讲解。

* 嵌入式linux设备驱动开发详解

* 嵌入式系统linux内核开发实战指南

..
   术语
   ====


     * 总线

       AMBA    Advanced Microcontroller Bus Architecture(高级微控制器总线体系)
               ACE     AXI Coherency Extensions
               AXI     Advanced eXtensible Interface
               AHB     Advanced High-performance Bus(高级高性能总线)
               ASB     Advanced System Bus
               APB     Advanced Peripheral Bus(高级外设总线)

       EBI     External Bus Interface(外部总线接口)

     * 时钟

     PLLs    Phase Locked Loop

====================
各子系统裸机开发笔记
====================

系统初始化
==========

包括两个步骤，第一步是告诉CPU外设的地址，这样在访问外设时就可以像访问内存那样方便。第二步是禁用电子狗。

* 外设地址映射

  首先，我们需要告诉CPU外设的地址，这样在访问外设时就可以像访问内存那样方便。

    .. image:: ./img/datasheet_init_peripheral.png

  从6410的datasheet上可以看出，外设的地址是0x7000_0000~0x7FFF_0000，大小为256M(即2^28)。所需指令为

  ::

    ldr r0, =0x70000000
    orr r0, r0, #0x13
    mcr p15, 0, r0, c15, c2, 4

  这里用到了arm的协处理器CP15，协处理器包含了16个32位的寄存器，这里使用到的是c15，它的格式如下(取自arm1176手册arm1176jzfs.pdf)

    .. image:: ./img/arm1176jzfs_c15_format.png

  下面是对c15寄存器进行操作的指令格式

    .. image:: ./img/arm1176jzfs_c15_readwrite.png

  由于我们的外设地址大小是256M，从图中可以看出c15的最低5位需要设置为b10011，即0x13。

  ::

    orr r0, r0, #0x13

* 关闭电子狗

  .. image:: ./img/datasheet_watchdog_WTCON.png

  将WTCON最低位置0即可。

  ::

    ldr r0, =0x7E004000
    mov r1, #0
    str r1, [r0]

LED
===

.. image:: ./img/board_led.png

上图为tiny6410核心板原理图关于LED的部分，可以看出led1-4由GPK4-7控制，并且这些引脚是复用引脚，点亮led需要对应的引脚为为低电平。

.. image:: ./img/datasheet_led_register.png

这是tiny6410的datasheet中关于GPK寄存器的截图。我们的目的是让led根据设置的引脚来相应地发生变化，所以它们应该为输出模式，从图可以看出GPK4-7分别由GPKCON0的[19:16]、[23:20]、[27:24]和[31:28]控制，需要将其分别设置为b0001。

GPK4-7的值可以通过向GPKDAT[n]对应的位写入即可。

时钟
====

* 概述

  .. image:: ./img/datasheet_clock_3-2.png

  这是tiny6410的datasheet中图3-2，为时钟的总体布局图。

  6410有很多时钟，比如CPU时钟、总线时钟和各种外设时钟，时钟源也有很多，有一个主时钟源和其它次要的时钟源。主时钟源通过转换，生成6410的几个最主要的时钟：CPU时钟、AXI/AHB总线时钟和APB总线时钟，分别对应于上图中的ARMCLK、HCLK和PCLK。

  6410有3个PLL来转换生成这三种不同的时钟：即上图中的APLL(ARM PLL)、MPLL(Main PLL)和EPLL(extra PLL)，它们的输入时钟都是上面的主时钟源。我们可以将PLL看成一个黑盒子，它将一个时钟输入转换为另一个时钟输出。

  主时钟源可以选择外部晶体(XXTlpll)(通过晶振产生时钟)或者直接选择一个外部时钟(XEXTCLK)，由OM[0]的值来决定，为0时选择外部晶体，为1时选择外部时钟。

* 寄存器配置原理

  我们在配置时钟时，将需求降到最低，即满足系统运行最基本的要求即可，暂时不需要使用EPLL，所以相关的寄存器就不需要配置。基本配置可以对照下图来确定，这是datasheet上图3-4。

  .. image:: ./img/datasheet_clock_3-4.png

  - 时钟源设置

    MUX(APLL)，通过设置CLK_SRC[0]决定CPU时钟直接来自于外部时钟还是来自于APLL的输出。

    MUX(MPLL)，通过设置CLK_SRC[1]决定总线时钟来自于外部时钟还是来自于MPLL的输出。

    OTHERS[6]决定总线时钟是否来自于CPU时钟。如果OTHERS[6]设置为1，则MPLL的相关设置以及CLK_SRC[1]的值便可以忽略。

    另外，OTHERS[7]则决定总线时钟是否和CPU始终保持同步，设置了OTHERS[7]之后可以对OTHERS[11:8]进行检测以便确认已经同步。如果设置为同步模式，稳定了之后这几位为1；如果设置为异步模式，则稳定了之后这几位为0。详见下图关于OTHERS寄存器的描述。(?随后确认)

    .. image:: ./img/datasheet_clock_OTHERS.png

  - 分频器设置

    .. image:: ./img/datasheet_clock_3-5.png


    可以对照此图来设置。

    MISC_CON[19]设置为0，传入DIV(ARM)和DIV(HCLKX2)之前不进行分频。

    DIV(ARM)对应于CLK_DIV0[3:0]，设置为0。 ``Fout(APLL) = ARMCLK``

    DIV(HCLKX2)对应于CLK_DIV0[11:9]，设置为1。 ``ARMCLK = 2 * HCLKX2``

    DIV(HCLK)对应于CLK_DIV0[8]，设置为1。 ``HCLKX2 = 2 * HCLK``

    DIV(PCLK)对应于CLK_DIV0[15:12]，设置为3。 ``HCLKX2 = 4 * PCLK``

    .. image:: ./img/datasheet_clock_CLK_DIV0.png

    这样配置结果为

    ::

      ARMCLK = 2 * HCLKX2 = 4 * HCLK = 8 * PCLK = 533MHz

  - PLL设置

    包括倍率设置和lock time设置。

    * 倍率设置

      PLL的倍率转换公式

      ::

        输出时钟频率 = 输入时钟频率 * MDIV / (PDIV * (2 ^ SDIV))

      公式中除了输入时钟频率之外，其他三个参数都是在PLL寄存器中设置。寄存器APLL_CON和MPLL_CON的最高位为控制是否启用这个PLL，这两个寄存器的[25:16]、[13:8]和[2:0]分别控制相应的PLL的三个值：MDIV、PDIV和SDIV，其余的位为0。详见下图

      .. image:: ./img/datasheet_clock_PLL_CON.png

      下图为关于转换公式的具体描述

      .. image:: ./img/datasheet_clock_APLL_calc.png

      从tiny6410核心板原理图上可以看出我们使用的是频率为12MHz的晶振。所以当需求输出频率为533时，MDIV、PDIV和SDIV的值分别为266、3和1。

    * lock time设置

      .. image:: ./img/datasheet_clock_PLL_LOCK.png

      某个PLL的locktime可以理解为这个PLL从开始工作到输出到预期的稳定时钟需要经历的时间，预设值一般为0xFFFF，在这段时间内，这个PLL的输出时钟为0。寄存器APLL_LOCK/MPLL_LOCK/EPLL_LOCK　的高十六位固定为0，低十六位为各自对应的locktime。

* 配置步骤

  1. 先配置OTHERS[6]和OTHERS[7]，然后确认进入同步模式
  #. 配置各个PLL的PLL_LOCK，保证有稳定的时钟输出
  #. 配置分频比例，保证ARMCLK、HCLKX2、HCLK和PCLK符合最终的比例
  #. 分别配置每个用到的PLL，通过PLL将初始的时钟频率提升到与最终时钟频率为同一量级
  #. 配置每个用到的PLL输出的的MUX选择器，最终输出预期的时钟频率

..
   下面是在 openocd 的配置文件中配置时钟的例子

   ::

      # 将OTHERS[6]设为1，将总线时钟的"同步模式选择器"置为1，见图3-4中的"SYNCMUX"
      mww 0x7E00F900 0x805e        ;# OTHERS    - Change SYNCMUX[6] to “1”
      sleep 1000
      # 将OTHERS[7]设为1，将总线时钟与CPU时钟设为同步模式
      mww 0x7E00F900 0x80de        ;# OTHERS    - Assert SYNCREQ&VICSYNCEN to “1”(rb1004modify)
      sleep 1000                   ;#           - Others[11:8] to 0xF

      # 设置APLL和MPLL的lock_time，为固定值
      mww 0x7E00F000 0xffff        ;# APLL_LOCK    - APLL LockTime
      mww 0x7E00F004 0xffff        ;# MPLL_LOCK    - MPLL LockTime

      # 设置 CLK_DIV0 (0000_0001_0000_0100_0111_0011_0001_0000)
      # CLK_DIV0[31:28]: MFC_RATIO    = 0000
      # CLK_DIV0[27:24]: JPEG_RATIO   = 0001
      # CLK_DIV0[23:20]: CAM_RATIO    = 0000
      # CLK_DIV0[19:18]: SECUR_RATIO  = 01
      # CLK_DIV0[17:16]: RESERVED     = 00
      # CLK_DIV0[15:12]: PCLK_RATIO   = 0111
      # CLK_DIV0[11:9]:  HCLKX2_RATIO = 001
      # CLK_DIV0[8]:     HCLK_RATIO   = 1
      # CLK_DIV0[7:5]:   RESERVED     = 000
      # CLK_DIV0[4]:     MPLL_RATIO   = 1
      # CLK_DIV0[3:0]:   ARM_RATIO    = 0000
      # 注意上面已将OTHER6[6]设置为1，则MPLL_RATIO的值不会影响HCLK和PCLK。
      # 所以最终
      #   ARMCLK = APLL_OUT/(ARM_RATIO+1) = APLL_OUT
      #   HCLK = [APLL_OUT/(HCLKX2_RATIO+1)] / (HCLK_RATIO+1) = APLL_OUT/4
      #   PCLK = [APLL_OUT/(HCLKX2_RATIO+1)] / (PCLK_RATIO+1) = APLL_OUT/16
      mww 0x7E00F020 0x1047310    ;# CLK_DIV0     - ARMCLK:HCLK:PCLK = 1:4:16

      # 设置 APLL_CON (1000_0001_1001_0000_0000_0011_0000_0010)
      # 设置 MPLL_CON (1000_0001_1001_0000_0000_0011_0000_0011)
      #              |E|-----|-----A/M----|-|---P---|-----|-s-|
      mww 0x7E00F00c 0x81900302    ;# APLL_CON     - A:400, P:3, S:2 => 400MHz
      mww 0x7E00F010 0x81900303    ;# MPLL_CON     - M:400, P:3, S:3 => 200MHz

      # 设置 CLK_SRC ， 表明将会使用APLL和MPLL
      # CLK_SRC[1]: MPLL_SEL = 1
      # CLK_SRC[0]: APLL_SEL = 1
      mww 0x7E00F01c 0x3            ;# CLK_SRC         - APLL,MPLL Clock Select

串口UART
========

.. image:: ./img/datasheet_uart_31-1.png

此图为UART的内部原理图。

UART内部包含有一个数据发送缓冲区和一个数据接收缓冲区，都称为FIFO，还有一个数据发送器(Transmit Shifter)以及一个数据接收器(Receiver Shifter)。如果启用FIFO，发送数据时，先存入FIFO，然后数据发送器从中一个一个取出数据并发送。接收时采用相同的方法。

在发送数据时，发送器会先发送一个起始位，接着发送5个、6个、7个或者8个字节的数据位，然后是一个可选的奇偶校验位以及1个或者2个停止位。接收数据时也是按照类似的方式进行。数据接收器还可以检测到数据的过载错误、奇偶校验错误、帧错误等等。

下面以配置uart0为例，配置的内容包括:


* 引脚

  .. image:: ./img/board_uart.png

  上图为tiny6410核心板原理图，由于uart引脚为复用引脚，需要将其配置为供uart使用的引脚，只需配置GPA0和GPA1。

  .. image:: ./img/datasheet_uart_GPACON.png

  ::

      GPACON = setval(GPACON, 7, 0, 0x22);

* UART行控制寄存器ULCONn(UART LINE CONTROL REGISTER)

  .. image:: ./img/datasheet_uart_ULCONn.png

  我们通过设置ULCON0寄存器将uart0设置为禁用红外模式、禁用奇偶校验、停止位为1位，发送或者接受时每一帧里包括8个数据位。

  ::

      ULCON0 = 0x3;

* UART控制寄存器UCONn(UART CONTROL REGISTER)

  .. image:: ./img/datasheet_uart_UCONn_1.png
  .. image:: ./img/datasheet_uart_UCONn_2.png

  我们将时钟源设置为PCLK，将接受和发送模式都设置为中断/轮询模式、禁用超时检测、禁用回环模式等等

  ::

      UCON0  = 0x5;

* UART缓冲区寄存器UFCONn(UART FIFO CONTROL REGISTER)

  .. image:: ./img/datasheet_uart_UFCONn.png

  设置的结果为:启用FIFO，接受缓冲区收到1个字节就触发信号，而发送缓冲区则是在全部发送完成之后即发送缓冲区为空的时候触发信号。

  ::

      UFCON0 = 0x1;

* UARTmodem寄存器UMCONn(UART MODEM CONTROL REGISTER)

  .. image:: ./img/datasheet_uart_UMCONn.png

  禁用自动流量控制、禁用modem interrupt等

  ::

     UMCON0 = 0x0;

* UART时钟和波特率设置(UART CLOCK AND PCLK RELATION)

  包括UBRDIVn和UDIVSLOTn这两个寄存器。

  .. image:: ./img/datasheet_uart_UBRDIVn.png

  .. image:: ./img/datasheet_uart_UDIVSLOTn.png

  uart的时钟来自于PCLK，在设置时钟部分我们可以知道PCLK=(533/8)HMz。uart的波特率我们采用通用的115200。uart的时钟和波特率的关系如下:

  ::

      DIV_VAL = UBRDIVn + (num of 1’s in UDIVSLOTn)/16
      DIV_VAL = (PCLK / (bps x 16 ) ) −1

  所以

  ::

    UBRDIVn + (num of 1’s in UDIVSLOTn)/16 = (PCLK / (bps x 16 ) ) −1

  其中

  ::

     PCLK = (533*10^6)/8
     bps = 115200

  由此我们可以计算出

  ::

      UBRDIV0 + (num of 1’s in UDIVSLOT0)/16
          = ((553*10^6/8) / (115200*16)) - 1
          = 36.5027

  所以可以将UBRDIV0设置为36，即0x24,可将UDIVSLOT0设置为0xFF(这样它包含1的个数为8)。最终设置如下

  ::

    UBRDIV0 = 0x24;
    UDIVSLOT0 = 0xFF;

* 通过串口进行读写

  涉及到UFSTAT0，URXH0和UTXH0这三个寄存器。

  .. image:: ./img/datasheet_uart_UFSTATn.png

  最简单的方式是通过轮询UFSTAT0中相应的读写状态位，发送数据时，一旦检测到发送缓冲区为空，则可将发送的字符直接写入UTXH0寄存器即可，接收数据时，一旦检测到接收缓冲区有内容，则可直接读取URXH0寄存器即可。

内存SDRAM
=========

概述
----

这部分相对来说感觉是有点复杂的，除了参考内存和内存控制器的手册外，可能还需要一些背景知识，可google以下两篇文章来了解

* 深入了解内存
* 高手进阶，终极内存技术指南——完整进阶版

下面是tiny6410核心板电路图关于内存部分的截图

.. image:: ./img/board_sdram.png

背景知识
--------

tiny6410带有2个大小为128M的Mobile DDR SDRAM的内存，具体型号为K4X1G163PE-FGC6，内存控制器为pl340。内存控制器为CPU和内存之间的一个中介，当CPU访问某个内存地址时，它只需要与内存控制器交互，然后由内存控制器具体向内存发出地址以及读写命令。

每个内存内部分成了n个bank，每个bank可以理解为一个内存块，而每个bank内部类似于一个表格，由行地址和列地址组成，一个行地址和一个列地址可以寻址的内容称为内存的最小存储单元。从内存手册中可以看出我们的内存的分成了4个bank。对于bank的寻址是由BA0和BA1引脚完成的。

我们使用的内存的容量规格为 ``64M*16`` ，其中的16表示每个内存中最小存储单元的容量(单位是bit)，也就是位宽，即可以有16条数据线同时访问，而其中的64M表示存储单元的数量，所以每个内存的容量为64M*16bit=128MB。根据上面的描述我们还可以计算出每个bank中存储单元的数量为64M/4=16M。

Mobile DDR SDRAM的实现决定了它内部需要进行"刷新"，也就是所谓的"充电"，否则时间长了数据就会慢慢丢失。而刷新操作有2种方式，第一种是auto refresh，也就是自动刷新，这实际上是内存控制器自动刷新内存，第二种方式是self refresh，也就是内存自我刷新，比如在系统待机时，内存会进行自我刷新。

访问方式，分为顺序访问和突发访问，前者是指依次发送一系列行地址和列地址而进行的常规访问，而突发访问(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输所涉及到存储单元（列）的数量就是突发长度（Burst Lengths，简称BL）。只要指定起始列地址与突发长度，内存就会依次地自动对后面相应数量的存储单元进行读/写操作而不再需要控制器连续地提供列地址。

时间参数
~~~~~~~~

tRAC
  行存取时间，即激活RASh和数据最终出现在数据总线之间的时间

tCAC
  列存取时间，即激活RASh和数据最终出现在数据总线之间的时间

tRCD (RAS to CAS delay)
  在发送列读写命令时必须要与行有效命令有一个间隔，这个间隔被定义为
  tRCD，即RAS to CAS Delay（RAS至CAS延迟）

tCAS
  在CAS发出之后，仍要经过一定的时间才能有数据输出，从CAS与读取命令发
  出到第一笔数据输出的这段时间，这就是tCAS，又被称为CL（CAS Latency，
  CAS潜伏期）。由于CL只在读取时出现，所以CL又被称为读取潜伏期（RL，
  Read Latency）。

tRP (row precharge)
  在发出预充电命令之后，要经过一段时间才能允许发送RAS行有效命令打开新
  的工作行，这个间隔被称为tRP（Precharge command Period，预充电有效周
  期）。

tRAS (row active time)
  tRAS is the minimum number of clock cycles needed to access a
  certain row of data in RAM between the data request and the
  precharge command. It's known as active to precharge
  delay. According to Mushkin.com, in practice for DDR SDRAM, this
  should be set to at least tRCD + tCAS + 2 to allow enough time for
  data to be streamed out. [1]. It stands for row address strobe
  time.

tAC
  从数据I/O总线上有数据输出之前的一个时钟上升沿开始，数据即已传向S-AMP，
  也就是说此时数据已经被触发，经过一定的驱动时间最终传向数据I/O总线进行
  输出，这段时间我们称之为tAC（Access Time from CLK，时钟触发后的访问时
  间）。

tWR
  为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR，Write
  Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个
  时钟周期或再多一点（时钟频率越高，tWR占用周期越多）。

..
   术语
   ~~~~

   Clock cycle time (tCK)

   Row cycle time (tRC)

   Row active time (tRAS)

   RAS to CAS delay (tRCD)

   Row precharge time (tRP)

   Row active to Row active delay (tRRD)

   Write recovery time (tWR)

   Last data in to Active delay (tDAL)

   Last data in to Read command (tCDLR)

   Col. address to Col. address delay (tCCD)

   Clock high level width (tCH)

   Clock low level width (tCL)

   DQ Output data access time from CK/CK (tAC)

   DQS Output data access time from CK/CK (tDQSCK)

   Data strobe edge to ouput data edge (tDQSQ)

   Read Preamble (tRPRE)

   Read Postamble (tRPST)

   CK to valid DQS-in (tDQSS)

   DQS-in setup time (tWPRES)

   DQS-in hold time (tWPREH)

   DQS-in high level width (tDQSH)

   DQS-in low level width (tDQSL)

   DQS falling edge to CK setup time (tDSS)

   DQS falling edge hold time from CK (tDSH)

   DQS-in cycle time (tDSC)

   Address and Control Input setup time (tIS)

   Address and Control Input hold time (tIH)

   Address & Control input pulse width (tIPW)

   DQ & DM setup time to DQS (tDS)

   DQ & DM hold time to DQS (tDH) 0.8 1.1 ns 5,6

   DQ & DM input pulse width (tDIPW)

   DQ & DQS low-impedence time from CK/CK (tLZ)

   DQ & DQS high-impedence time from CK/CK (tHZ)

   DQS write postamble time (tWPST)

   DQS write preamble time (tWPRE)

   Refresh interval time (tREF)

   Mode register set cycle time (tMRD)

   Power down exit time (tPDEX)

   CKE min. pulse width(high and low pulse width) (tCKE)

   Auto refresh cycle time (tRFC)

   Exit self refresh to active command (tXSR)

   Data hold from DQS to earliest DQ edge (tQH)

   Data hold skew factor (tQHS)

   Clock half period (tHP)

初始化
------

初始化内存控制器的步骤如下

1. 将b100写入memc_cmd，使内存控制器进入'config'模式

   ::

     P1MEMCCMD = setval(P1MEMCCMD, 2, 0, 0x4);

2. 内存控制器本身的初始化，包括设置内存的某些参数，比如刷新周期和各种时序参数等等

   * 刷新周期设置

     设置的刷新周期要以内存的时钟周期为单位，内存的时钟来自于HCLK，在之前的配置中可以知道HCLK为533/4MHz。从内存手册中看出刷新周期为7.8us，需要转换成内存的时钟周期。

     ::

       #define MEM_FREQUENCY    (533/4)
       #define ns2ck(ns)        (MEM_FREQUENCY * (ns) / 1000 + 1)
       P1REFRESH = setval(P1REFRESH, 14, 0, ns2ck(7800));

   * 内存参数设置

     设计到的寄存器包括P1MEMCFG、P1MEMCFG2。

     首先先来设置P1MEMCFG，下面是它各个位的含义

     .. image:: ./img/datasheet_sdram_P1MEMCFG_1.png
     .. image:: ./img/datasheet_sdram_P1MEMCFG_2.png

     - 行地址位数和列地址位数

       下面是内存手册上的截图

       .. image:: ./img/sdram_address_conf.png

       可以看出行地址位数和列地址位数分别为14位和10位:

       ::

         P1MEMCFG = setval(P1MEMCFG, 5, 3, 0x3);
         P1MEMCFG = setval(P1MEMCFG, 2, 0, 0x2);

       .. image:: ./img/sdram_precharge_bit_conf.png

     - 自动预充电位设置

       自动预充电位为内存地址中的第10位:

       ::

         P1MEMCFG = setval(P1MEMCFG, 6, 6, 0x0);

     - 突发访问长度设置

       对于突发访问的长度，内存手册上支持2、4、8、16，我们将其设置为4。

       ::

         P1MEMCFG = setval(P1MEMCFG, 17, 15, 0x2);

     接着我们来设置P1MEMCFG2，下面是它各个位的含义

     .. image:: ./img/datasheet_sdram_P1MEMCFG2.png

     - 内存类型设置

       我们内存类型设为Mobile DDR SDRAM:

       ::

         P1MEMCFG2 = setval(P1MEMCFG2, 10, 8, 0x3);

     - 位宽设置

       从开发板核心板原理图上可以看出，内存是由两块内存组合起来使用的，每个位16位，总共位宽为32位:

       ::

         P1MEMCFG2 = setval(P1MEMCFG2, 7, 6, 0x1);

     - 其它设置

       ::

        P1MEMCFG2 = setval(P1MEMCFG2, 12, 11, 0x1);
        P1MEMCFG2 = setval(P1MEMCFG2, 3, 2, 0x0);
        P1MEMCFG2 = setval(P1MEMCFG2, 0, 0, 0x1);

   * 时序设置

     ::

       P1CASLAT = setval(P1CASLAT, 0, 0, 0x0);
       P1CASLAT = setval(P1CASLAT, 3, 1, 0x3);
       P1T_DQSS = setval(P1T_DQSS, 1, 0, 0x1);
       P1T_MRD  = setval(P1T_MRD, 6, 0, 0x2);
       P1T_RAS  = setval(P1T_RAS, 3, 0, ns2ck(42));
       P1T_RC   = setval(P1T_RC, 3, 0, ns2ck(60));
       P1T_RCD  = setval(P1T_RCD, 2, 0, ns2ck(18));
       P1T_RCD  = setval(P1T_RCD, 5, 3, ns2ck(18) - 3);
       P1T_RFC  = setval(P1T_RFC, 4, 0, ns2ck(80));
       P1T_RFC  = setval(P1T_RFC, 9, 5, ns2ck(80) - 3);
       P1T_RP   = setval(P1T_RP, 2, 0, ns2ck(18));
       P1T_RP   = setval(P1T_RP, 5, 3, ns2ck(18) - 3);
       P1T_RRD  = setval(P1T_RRD, 3, 0, ns2ck(12));
       P1T_WR   = setval(P1T_WR, 2, 0, ns2ck(12));
       P1T_WTR  = setval(P1T_WTR, 2, 0, 0x2); /* ??? */
       P1T_XP   = setval(P1T_XP, 7, 0, 0x2);  /* ??? */
       P1T_XSR  = setval(P1T_XSR, 7, 0, ns2ck(120));
       P1T_ESR  = setval(P1T_ESR, 7, 0, ns2ck(120)); /* ??? */

3. 执行内存初始化

   内存初始化的配置代码根据内存类型的不同而不同，tiny6410的内存为 ``Mobile DDR SDRAM`` 类型，具体步骤如下:

   注意:6410 datasheet上第5.4.3一节所使用的配置代码是错误的。

   1. 将b11写入direct_cmd，使内存控制器发出'NOP'内存命令。
   #. 将b00写入direct_cmd，使内存控制器发出'Prechargeall'内存命令。
   #. 将b01写入direct_cmd，使内存控制器发出'Autorefresh'内存命令。
   #. 将b01写入direct_cmd，使内存控制器发出'Autorefresh'内存命令。
   #. 将b10写入direct_cmd，使内存控制器发出'EMRS'内存命令。并且需要配置EMRS寄存器
   #. 将b10写入direct_cmd，使内存控制器发出'MRS'内存命令。并且需要配置MRS寄存器

   .. image:: ./img/datasheet_sdram_PnDIRECTCMD.png

   代码如下

   ::

     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x3); /* NOP */
     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x0); /* Prechargeall */
     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x1); /* Autorefresh */
     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x1); /* Autorefresh */

     /* set EMRS and MRS, refer to K4X1G163PE-FGC6(8)_R11.pdf */

     P1DIRECTCMD = 0xa0000;
     P1DIRECTCMD = 0x80032;

     MEM_SYS_CFG = 0;


   注意在设置EMRS和MRS时，不能分开赋值，上面代码中最后两条给P1DIRECTCMD赋值的语句不能写成如下形式，虽然表面看没有什么区别:

   ::

     P1DIRECTCMD = setval(P1DIRECTCMD, 17, 16, 0x2);	  /* EMRS Bank Addr */
     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x2);   /* EMRS */
     P1DIRECTCMD = setval(P1DIRECTCMD, 13, 0, 0x32);
     P1DIRECTCMD = setval(P1DIRECTCMD, 17, 16, 0x0);   /* MRS Bank Addr */
     P1DIRECTCMD = setval(P1DIRECTCMD, 19, 18, 0x2);   /* MRS */

4. 将b000写入memc_cmd，使内存控制器进入'go'模式

   ::

     P1MEMCCMD = setval(P1MEMCCMD, 2, 0, 0x0);

5. 检测内存状态寄存器memc_stat直到表示内存的状态的值为b01，表明进入了'ready'状态

   ::

     while (getval(P1MEMSTAT, 1, 0) == 0x1)
         break;

..
   CASL    3
   tDQSS   1
   tMRD    2
   tRAS    42ns
   tRC     60ns
   tRCD    18ns
   tRFC    80ns
   tRP     18ns
   tRRD    12ns
   tWR     12ns
   tWTR    <2>
   tXP     <2>
   tXSR    120ns
   tESR    <120ns>

   疑难点

   * P1T_WTR、P1T_XP、P1T_ESR这三个时间参数在内存手册上没有，如何得出？

   * P1MEMCFG2[12:11, 3, 2, 1, 0]分别代表什么含义？

   * P1_chip_0_cfg寄存器中各位的含义?

   * MEM_SYS_CFG寄存器中各位的含义? 似懂非懂

   * MRS和EMRS分别代表什么含义？如何设置他们的bank地址？已解决

硬盘NandFlash
=============

概述
----

.. image:: ./img/board_nand.png

这是nand flash的电路图。


背景知识
--------

.. image:: ./img/nand_organization.png

整个nand flash由2076个块(block)组成，每个块(block)由128个页(page)组成，而每个页的大小为8K，读写的最小单位就是page。每一页附带有436字节的错误校验码，这部分属于另外的空间，不属于平时访问的nand flash地址空间，读取错误校验码需要使用特殊的读命令。另外，在访问nand flash时，块和页的地址合起来称为行(row)地址，而页内偏移地址又称为列(column)地址。

nand flash的地址、命令和数据传输共用同样的IO端口，有专门的引脚来指示当前传输的是地址、命令或者是数据。发送地址时，分多次发送，见上图。

初始化
------

* 时序设置

  datasheet上需要设置三个时序，如下图所示:

  .. image:: ./img/datasheet_nand_time.png

  上面的时序图中的nWE和nRE都应该是低电平有效，图中错误。

  .. image:: ./img/datasheet_nand_time_register.png

  这是时序对应寄存器的各个位。

  设置时序时涉及到nand flash的时钟，我们可以知道来自于HCLK，值为266MHz，换算后大约为3.76ns。

  - TACLS

    这是从CLE/ALE变成有效之后，间隔多长时间WE变成有效，对应于nand flash手册中时序图(tCLS-tWP)和(tALS-tWP)这两个值中的较小的那个。tCLS、tALS和tWP都最小为15ns，所以这个值设为0或者1都可以。

  - TWRPH0

    这是WE和RE所持续的时间，对应于nand flash手册中时序图tWP和tRP这两个值中的较小的那个，这两个值都最小为15ns。而换算公式为:

    ::

      持续时间=HCLK*(TWRPH0+1)

    其中的持续时间最小为15ns，HCLK为3.76ns，所以TWRPH0设置为3或4或者更大的值都可以。由于对应的寄存器只有三位，所以最大为7。

  - TWRPH1

    这是WE和RE变成无效之后，CLE/ALE还持续多长时间，对应于nand flash手册中时序图tCLH和tALH这两个值中的较小的那个，这两个值都最小为5ns。而换算公式为:

    ::

      持续时间=HCLK*(TWRPH1+1)

    其中的持续时间最小为5ns，HCLK为3.76ns，所以TWRPH1设置为1即可。

  所以最终的时序设置如下:

  ::

    NFCONF = setval(NFCONF, 6, 4, 1);	/* TWRPH1 */
    NFCONF = setval(NFCONF, 10, 8, 3);  /* TWRPH0 */
    NFCONF = setval(NFCONF, 14, 12, 0); /* TACLS */

* 读写过程

* 发送地址

  向NFADDR寄存器里写入地址即可，但注意只有[7:0]位有效，要按照nand flash手册上写的步骤分5次发送，每次发送8位。因此发送一个32位的地址时需要将它拆分计算出每次发送的8位值。



中断和异常
==========

MMU
===
..
   ==========
   u-boot移植
   ==========


   来自u-boot的README

   ::

     If the system board that you have is not listed, then you will need
     to port U-Boot to your hardware platform. To do this, follow these
     steps:

     1.  Add a new configuration option for your board to the toplevel
         "boards.cfg" file, using the existing entries as examples.
         Follow the instructions there to keep the boards in order.
     2.  Create a new directory to hold your board specific code. Add any
         files you need. In your board directory, you will need at least
         the "Makefile", a "<board>.c", "flash.c" and "u-boot.lds".
     3.  Create a new configuration file "include/configs/<board>.h" for
         your board
     3.  If you're porting U-Boot to a new CPU, then also create a new
         directory to hold your CPU specific code. Add any files you need.
     4.  Run "make <board>_config" with your new name.
     5.  Type "make", and you should get a working "u-boot.srec" file
         to be installed on your target system.
     6.  Debug and solve any problems that might arise.
         [Of course, this last step is much harder than it sounds.]

..
   ==========
   kernel移植
   ==========

   系统启动代码分析
   ================

   汇编语言文件的基本结构:

   * 函数

     以 ``ENTRY()`` 为标记为函数开始，以 ``ENDPROC()`` 标记为此函数结束。例如:

     ::

       ENTRY(__turn_mmu_on)
           mov	r0, r0
           instr_sync
           mcr	p15, 0, r0, c1, c0, 0		@ write control reg
           mrc	p15, 0, r3, c0, c0, 0		@ read id reg
           instr_sync
           mov	r3, r3
           mov	r3, r13
           mov	pc, r3
       __turn_mmu_on_end:
       ENDPROC(__turn_mmu_on)

   linux-3.10/arch/arm/kernel/head.S
   ---------------------------------

   linux-3.10/arch/arm/kernel/head-common.S
   ----------------------------------------

==========
u-boot移植
==========

所需参数

::

  ARCH   = arm
  CPU    = s3c64xx
  BOARD  = tiny6410
  VENDOR = samsung
  SOC    = s3c6410

修改为

::

  ARCH   = arm
  CPU    = arm1176
  BOARD  = tiny6410
  VENDOR = samsung
  SOC    = s3c6410

所涉及到的文件

::

  /board/arm/tiny6410/    # 在 config.h 中定义
  /arch/arm/cpu/arm1176   # 未明确定义

  # 在/mkconfig脚本中定义
  if [ "${soc}" ] ; then
      # /arch/arm/include/asm/arch-s3c6410
      ln -s ${LNPREFIX}arch-${soc} asm/arch
  elif [ "${cpu}" ] ; then
      # /arch/arm/include/asm/arch-arm1176
      ln -s ${LNPREFIX}arch-${cpu} asm/arch
  fi

对于最新版u-boot，使用make rpi_b_config后生成的文件

::

  if [ "${soc}" ] ; then
      ln -s ${LNPREFIX}arch-${soc} asm/arch
  elif [ "${cpu}" ] ; then
      ln -s ${LNPREFIX}arch-${cpu} asm/arch
  fi

  /* Automatically generated - do not edit */
  #define CONFIG_SYS_ARCH  "arm"
  #define CONFIG_SYS_CPU   "arm1176"
  #define CONFIG_SYS_BOARD "rpi_b"
  #define CONFIG_SYS_VENDOR "raspberrypi"
  #define CONFIG_SYS_SOC    "bcm2835"
  #define CONFIG_BOARDDIR board/raspberrypi/rpi_b
  #include <config_cmd_defaults.h>
  #include <config_defaults.h>
  #include <configs/rpi_b.h>
  #include <asm/config.h>
  #include <config_fallbacks.h>
  #include <config_uncmd_spl.h>

========
内核移植
========

编译
====

找到相应的默认配置，例如arch/arm/configs/s3c6400_defconfig，然后 `make s3c6400_defconfig` ，再进行 `make menuconfig`

uImage是由真正的内核加一个头部组成。

配置
====
.config ==>
include/config/auto.conf -> Makefile
include/linux/autoconf.h

源代码分析
==========

- arch/arm/kernel/head.S

  - 判断是否支持当前CPU
  - 建立页表
  - 启用MMU
  - 跳转到start_kernel(init/main.c)
